Sections:
00: "org0001:0" (0-10000)


Source: "rom.asm"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3:         include "68000sbc.inc"

Source: "68000sbc.inc"
                            	     1:         include "memory.inc"

Source: "memory.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ROMSIZE         equ     $010000 ;64KB
                            	     4: RAMSIZE         equ     $100000 ;1MB
                            	     5: RAMEND          equ     RAM+RAMSIZE
                            	     6: INITIAL_SP      equ     RAMEND
                            	     7: ;-------------------------------------------------------------------------------
                            	     8: ; Base addresses
                            	     9: ROM             equ     $000000
                            	    10: RAM             equ     $E00000
                            	    11: ;-------------------------------------------------------------------------------
                            	    12: ; Memory reserved for the system
                            	    13: SYSMEMSTART     equ     RAM
                            	    14: SYSMEMSIZE      equ     256
                            	    15:                 rsset	SYSMEMSTART
                            	    16: OUTCH_VEC       rs.l    1
                            	    17: INCH_VEC        rs.l    1
                            	    18: HEXDIGITS       rs.l    1
                            	    19: SEPARATORS      rs.l    1
                            	    20: DATE_SEP        equ     SEPARATORS
                            	    21: TIME_SEP        equ     SEPARATORS+1
                            	    22: THOUSANDS_SEP   equ     SEPARATORS+2
                            	    23: 
                            	    24: ; Mounted filesystem parameters
                            	    25: PARTSIZE        rs.l    1               ; size of the partition in sectors, 0 = not mounted (4 bytes)
                            	    26: BPBSECTOR       rs.l    1               ; sector number of the partition's BIOS Parameter Block (4 bytes)
                            	    27: ; These parameters are in reverse order of those in the BPB,
                            	    28: ; because they are little-endian quantities that need to be byte-swapped
                            	    29: FATSIZE         rs.w    1               ; size of a FAT in sectors (2 bytes)
                            	    30: MAXRDIRENTS     rs.w    1               ; maximum number of root directory entries (2 bytes)
                            	    31: FATCOPIES       rs.w    1               ; number of FATs (padded to 2 bytes)
                            	    32: RSVDSECTORS     rs.w    1               ; number of reserved sectors (2 bytes)
                            	    33: CLUSTERSIZE     rs.w    1               ; number of sectors per cluster (2 bytes)
                            	    34: RDIRSECTOR      rs.l    1               ; sector number of root directory table (4 bytes)
                            	    35: FATSECTOR       rs.l    1               ; sector number of FAT #1 (4 bytes)
                            	    36: DATASTART       rs.l    1               ; sector number of data region start (4 bytes)
                            	    37: VOLNAME         rs.b    12              ; volume label (11 bytes, one extra for padding)
                            	    38: FSVARSTART      equ     PARTSIZE
                            	    39: FSVARLEN        equ     VOLNAME-FSVARSTART+12
                            	    40: 
                            	    41: INPUTBUFLEN     equ     64
                            	    42: INPUTBUF        rs.b    INPUTBUFLEN+2   ; command input buffer
                            	    43: 
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: ; Application programs can be loaded here
                            	    46: APPMEMSTART    equ     SYSMEMSTART+SYSMEMSIZE
                            	    47: 
                            	    48: 

Source: "68000sbc.inc"
                            	     2:         include "macros.inc"

Source: "macros.inc"
                            	     1: ; breakpoint (68000 does not have the BKPT instruction)
                            	     2: brk             macro
                            	     3:                 trap    #15
                            	     4:                 endm
                            	     5: 
                            	     6: ; set overflow flag
                            	     7: sev             macro
                            	     8:                 or      #%00000010,ccr
                            	     9:                 endm
                            	    10: 
                            	    11: ; clear overflow flag
                            	    12: clv             macro
                            	    13:                 and     #%11111101,ccr
                            	    14:                 endm
                            	    15: 
                            	    16: ; convenience alias for saving registers on stack
                            	    17: pushm           macro
                            	    18:         if NARG>1
                            	    19:         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	    20:         endif
                            	    21:                 movem.l \1,-(sp)
                            	    22:                 endm
                            	    23: push            macro
                            	    24:         if NARG>1
                            	    25:         fail    multiple args passed to push--use pushm if you want to push multiple registers
                            	    26:         endif
                            	    27:                 move.l  \1,-(sp)
                            	    28:                 endm
                            	    29: 
                            	    30: ; convenience alias for restoring registers from stack
                            	    31: popm            macro
                            	    32:         if NARG>1
                            	    33:         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	    34:         endif
                            	    35:                 movem.l (sp)+,\1
                            	    36:                 endm
                            	    37: pop             macro
                            	    38:         if NARG>1
                            	    39:         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	    40:         endif
                            	    41:                 move.l  (sp)+,\1
                            	    42:                 endm
                            	    43: 
                            	    44: ; Branch to subroutine and link, storing return address in A6.
                            	    45: ; (An optimization for calling leaf functions, a la Arm)
                            	    46: bl              macro
                            	    47:                 lea     (.ret\@,pc),a6
                            	    48:                 bra     \1
                            	    49: .ret\@:
                            	    50:                 endm
                            	    51: 
                            	    52: ; Spin for a given number of iterations. (0-65535)
                            	    53: ; (clobbers d0)
                            	    54: spin            macro
                            	    55:                 move.l  #\1,d0
                            	    56: .spin\@:        dbra    d0,.spin\@
                            	    57:                 endm
                            	    58: 
                            	    59: ; Return from subroutine to address in A6.
                            	    60: rl              macro
                            	    61:                 jmp     (a6)
                            	    62:                 endm
                            	    63: 
                            	    64: ; Declare null-terminated string.
                            	    65: asciz           macro
                            	    66:                 rept    \#
                            	    67:                 dc.b    \+
                            	    68:                 endr
                            	    69:                 dc.b    0
                            	    70:                 even
                            	    71:                 endm
                            	    72: 
                            	    73: ; Declare null-terminated string inline, place its address in A0, and jump
                            	    74: ; over it.
                            	    75: litstr          macro
                            	    76:                 lea.l   (.str\@,pc),a0
                            	    77:                 bra     .next\@
                            	    78: .str\@:
                            	    79:                 rept    \#
                            	    80:                 dc.b    \+
                            	    81:                 endr
                            	    82:                 dc.b    0
                            	    83:                 even
                            	    84: .next\@:
                            	    85:                 endm
                            	    86: 
                            	    87: ; Status register bit offsets
                            	    88: SR_C            equ     0       ; carry flag
                            	    89: SR_V            equ     1       ; overflow flag
                            	    90: SR_Z            equ     2       ; zero flag
                            	    91: SR_N            equ     3       ; negative flag
                            	    92: SR_X            equ     4       ; extend flag
                            	    93: SR_I            equ     8       ; interrupt mask
                            	    94: SR_S            equ     13      ; supervisor mode flag
                            	    95: SR_T            equ     15      ; trace flag
                            	    96: ; Condition code register (lower byte of status register) bit offsets
                            	    97: CCR_C           equ     SR_C
                            	    98: CCR_V           equ     SR_V
                            	    99: CCR_Z           equ     SR_Z
                            	   100: CCR_N           equ     SR_N
                            	   101: CCR_X           equ     SR_X
                            	   102: 
                            	   103: LOUD_NOISES     macro
                            	   104:                 move.l  #$d0d0dd00,d0
                            	   105:                 move.l  #$d1d1dd11,d1
                            	   106:                 move.l  #$d2d2dd22,d2
                            	   107:                 move.l  #$d3d3dd33,d3
                            	   108:                 move.l  #$d4d4dd44,d4
                            	   109:                 move.l  #$d5d5dd55,d5
                            	   110:                 move.l  #$d6d6dd66,d6
                            	   111:                 move.l  #$d7d7dd77,d7
                            	   112:                 move.l  #$a0a0aa00,a0
                            	   113:                 move.l  #$a1a1aa11,a1
                            	   114:                 move.l  #$a2a2aa22,a2
                            	   115:                 move.l  #$a3a3aa33,a3
                            	   116:                 move.l  #$a4a4aa44,a4
                            	   117:                 move.l  #$a5a5aa55,a5
                            	   118:                 move.l  #$a6a6aa66,a6
                            	   119:                 endm

Source: "68000sbc.inc"
                            	     3:         include "uart.inc"

Source: "uart.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ; base address
                            	     4: UART            equ $A00000
                            	     5: 
                            	     6: ; register offsets
                            	     7: RHR             equ 0   ; receive holding register (read)
                            	     8: THR             equ 0   ; transmit holding register (write)
                            	     9: IER             equ 2   ; interrupt enable register
                            	    10: ISR             equ 4   ; interrupt status register (read)
                            	    11: FCR             equ 4   ; FIFO control register (write)
                            	    12: LCR             equ 6   ; line control register
                            	    13: MCR             equ 8   ; modem control register
                            	    14: LSR             equ 10  ; line status register
                            	    15: MSR             equ 12  ; modem status register
                            	    16: SPR             equ 14  ; scratchpad register (reserved for system use)
                            	    17: DLL             equ 0   ; divisor latch LSB
                            	    18: DLM             equ 2   ; divisor latch MSB
                            	    19: ; aliases for register names (used by different manufacturers)
                            	    20: RBR             equ RHR ; receive buffer register
                            	    21: IIR             equ ISR ; interrupt identification register
                            	    22: SCR             equ SPR ; scratch register
                            	    23: 
                            	    24: ; MCR register bits (output lines)
                            	    25: ; A bit value of 1 drives the output low
                            	    26: MCR_COPI        equ 0   ; ~DTR -- bit 0 allows for easier shifting
                            	    27: MCR_LED         equ 1   ; ~RTS
                            	    28: MCR_CLK         equ 2   ; ~OUT1
                            	    29: MCR_nSS         equ 3   ; ~OUT2
                            	    30: 
                            	    31: ; MSR register bits (input lines)
                            	    32: MSR_BTN1        equ 6   ; ~RI
                            	    33: MSR_BTN1_PRESS  equ 2   ; TERI
                            	    34: MSR_SQW         equ 5   ; ~DSR
                            	    35: MSR_SQW_CHG     equ 2   ; deltaDSR
                            	    36: MSR_CIPO        equ 7   ; ~DSR -- bit 7 allows for easier shifting
                            	    37: 
                            	    38: ; Wait for the UART to become ready to transmit a character.
                            	    39: ; Macro argument 1: register containing the UART base address
                            	    40: tx_wait         macro
                            	    41: .t\@!:          btst.b  #5,LSR(\1)
                            	    42:                 beq     .t\@@
                            	    43:                 endm
                            	    44: 
                            	    45: ; Transmit a character on the serial port.
                            	    46: ; Macro argument 1: effective address of value to transmit
                            	    47: ; Macro argument 2: register containing the UART base address
                            	    48: tx_char         macro
                            	    49:                 tx_wait \2
                            	    50:                 move.b  \1,THR(\2)
                            	    51:                 endm
                            	    52: 
                            	    53: led_on          macro
                            	    54:                 bset.b  #MCR_LED,UART+MCR
                            	    55:                 endm
                            	    56: 
                            	    57: led_off         macro
                            	    58:                 bclr.b  #MCR_LED,UART+MCR
                            	    59:                 endm
                            	    60: 
                            	    61: led_tgl         macro
                            	    62:                 bchg.b  #MCR_LED,UART+MCR
                            	    63:                 endm

Source: "68000sbc.inc"
                            	     4:         include "cfcard.inc"

Source: "cfcard.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ; base address
                            	     4: CFCARD          equ     $900000
                            	     5: 
                            	     6: ; task file register offsets
                            	     7: CF_DATA         equ     0       ; data register (16-bit read/write)
                            	     8: CF_ERROR        equ     3       ; error register (8-bit read)
                            	     9: CF_FEATURE      equ     3       ; feature register (8-bit write)
                            	    10: CF_COUNT        equ     5       ; sector count register (8-bit read/write)
                            	    11: CF_SECTOR       equ     7       ; sector number register (8-bit read/write)
                            	    12: CF_LBA0         equ     7       ;  also, LBA bits 7-0
                            	    13: CF_CYLL         equ     9       ; cylinder low register (8-bit read/write)
                            	    14: CF_LBA1         equ     9       ;  also, LBA bits 15-8
                            	    15: CF_CYLH         equ     11      ; cylinder high register (8-bit read/write)
                            	    16: CF_LBA2         equ     11      ;  also, LBA bits 23-16
                            	    17: CF_DRIVEHEAD    equ     13      ; drive select/head register (8-bit read/write)
                            	    18: CF_LBA3         equ     13      ;  also, LBA bits 27-24
                            	    19: CF_STATUS       equ     15      ; status register (8-bit read)
                            	    20: CF_COMMAND      equ     15      ; command register (8-bit write)
                            	    21: 
                            	    22: ; task file register offsets for word access
                            	    23: CF_ERROR_W      equ     CF_ERROR-1
                            	    24: CF_FEATURE_W    equ     CF_FEATURE-1
                            	    25: CF_COUNT_W      equ     CF_COUNT-1
                            	    26: CF_SECTOR_W     equ     CF_SECTOR-1
                            	    27: CF_LBA0_W       equ     CF_LBA0-1
                            	    28: CF_CYLL_W       equ     CF_CYLL-1
                            	    29: CF_LBA1_W       equ     CF_LBA1-1
                            	    30: CF_CYLH_W       equ     CF_CYLH-1
                            	    31: CF_LBA2_W       equ     CF_LBA2-1
                            	    32: CF_DRIVEHEAD_W  equ     CF_DRIVEHEAD-1
                            	    33: CF_LBA3_W       equ     CF_LBA3-1
                            	    34: CF_STATUS_W     equ     CF_STATUS-1
                            	    35: CF_COMMAND_W    equ     CF_COMMAND-1
                            	    36: 
                            	    37: ; commands
                            	    38: CFCMD_IDENTIFY  equ     $EC
                            	    39: CFCMD_RDSECTOR  equ     $20
                            	    40: 
                            	    41: ; errors
                            	    42: ; if bit 5 is clear, it's an error reported by the card
                            	    43: ; if bit 5 is set, it's a filesystem error
                            	    44: FSERR_TIMEOUT   equ     32      ; no card detected
                            	    45: FSERR_WRONGTYPE equ     33      ; filesystem is not FAT16
                            	    46: FSERR_BPS       equ     34      ; bytes per sector is not 512
                            	    47: FSERR_NMOUNTED  equ     35      ; filesystem not mounted
                            	    48: FSERR_NOTFOUND  equ     36      ; file not found
                            	    49: FSERR_INVCLSTR  equ     37      ; invalid cluster number
                            	    50: FSERR_BADSECTOR equ     38      ; cluster contains a bad sector
                            	    51: FSERR_INVNAME   equ     39      ; invalid filename
                            	    52: FSERR_ISDIR     equ     40      ; file is a directory
                            	    53: 
                            	    54: ; Size of a sector. Hardcoded.
                            	    55: ; Drives with a different sector size are not supported.
                            	    56: SECTORSIZE      equ     512
                            	    57: ; Size of the buffer required for directory listing
                            	    58: DIRBUFSIZE      equ     SECTORSIZE+8
                            	    59: ; Size of a FAT16 directory entry
                            	    60: DIRENTLEN       equ     32
                            	    61: 
                            	    62: ; FAT16 directory entry field offsets
                            	    63: FNAME           equ     0
                            	    64: FNAMELEN        equ     11
                            	    65: FATTRS          equ     11
                            	    66: FCLUSTER        equ     26
                            	    67: FSIZE           equ     28
                            	    68: 

Source: "68000sbc.inc"
                            	     5:         include "syscalls.inc"

Source: "syscalls.inc"
                            	     1: ; Calling conventions for system routines
                            	     2: ;-------------------------------------------------------------------------------
                            	     3: ; D0-D1 - integer arguments
                            	     4: ; A0-A1 - pointer arguments
                            	     5: ; Additional arguments passed on the stack.
                            	     6: ;
                            	     7: ; D0-D1 - integer return values
                            	     8: ; A0-A1 - pointer return values
                            	     9: ; D2-D7 - preserved
                            	    10: ; A2-A7 - preserved
                            	    11: ; SR    - preserved
                            	    12: ;
                            	    13: ; Registers D0-D1/A0-A1 not used for return values may have undefined contents
                            	    14: ; upon return to the caller. (i.e. the callee may use them as scratch registers)
                            	    15: ;
                            	    16: ; The caller is responsible for removing arguments passed on the stack.
                            	    17: ;
                            	    18: Exit            equ     0
                            	    19: WaitBtn         equ     1
                            	    20: OutChar         equ     2
                            	    21: OutStr          equ     3
                            	    22: OutFmt          equ     4
                            	    23: InChar          equ     5
                            	    24: PromptStr       equ     6
                            	    25: ReadSector      equ     7
                            	    26: ListDirectory   equ     8
                            	    27: FindFile        equ     9
                            	    28: ReadFile        equ     10
                            	    29: GetDateTime     equ     11
                            	    30: SetDateTime     equ     12
                            	    31: GetSysInfo      equ     13
                            	    32: ; 14 - reserved for future use
                            	    33: Breakpoint      equ     15
                            	    34: 
                            	    35: 
                            	    36: ; Syscall macro.
                            	    37: sys             macro
                            	    38:                 trap    #\1
                            	    39:                 endm
                            	    40: 
                            	    41: ; format specifiers for OutFmt
                            	    42: FMT_BASE        equ     $E0
                            	    43: FMT_C           equ     FMT_BASE+0      ;pop word and print lsb as an ASCII character
                            	    44: FMT_C2          equ     FMT_BASE+1      ;pop word and print as two ASCII characters
                            	    45: FMT_C4          equ     FMT_BASE+2      ;pop longword and print as four ASCII characters
                            	    46: FMT_H8          equ     FMT_BASE+3      ;pop word and print lsb as two hex digits
                            	    47: FMT_H16         equ     FMT_BASE+4      ;pop word and print as four hex digits
                            	    48: FMT_H32         equ     FMT_BASE+5      ;pop longword and print as eight hex digits
                            	    49: FMT_S           equ     FMT_BASE+6      ;pop longword and print null-terminated ASCII string at address
                            	    50: FMT_U8          equ     FMT_BASE+7      ;pop word and print lsb as 1-3 decimal digits (unsigned)
                            	    51: FMT_U16         equ     FMT_BASE+8      ;pop word and print as 1-5 decimal digits (unsigned)
                            	    52: FMT_U32         equ     FMT_BASE+9      ;pop longword and print as 1-10 decimal digits (unsigned)
                            	    53: FMT_D8          equ     FMT_BASE+10     ;pop word and print lsb as 1-3 decimal digits (signed)
                            	    54: FMT_D16         equ     FMT_BASE+11     ;pop word and print as 1-5 decimal digits (signed)
                            	    55: FMT_D32         equ     FMT_BASE+12     ;pop longword and print as 1-10 decimal digits (signed)
                            	    56: FMT_Z8          equ     FMT_BASE+13     ;pop word and print lsb as 5 decimal digits with leading zeros (unsigned)
                            	    57: FMT_Z16         equ     FMT_BASE+14     ;pop word and print as 3 decimal digits with leading zeros (unsigned)
                            	    58: FMT_Z32         equ     FMT_BASE+15     ;pop longword and print as 10 decimal digits with leading zeros (unsigned)
                            	    59: FMT_SRFLAGS     equ     FMT_BASE+16     ;pop word and print as status register flags
                            	    60: FMT_FAULTFLAGS  equ     FMT_BASE+17     ;pop word and print as bus/address error fault flags
                            	    61: FMT_DATE        equ     FMT_BASE+18     ;pop longword and print as date (YYYY/MM/DD)
                            	    62: FMT_TIME        equ     FMT_BASE+19     ;pop longword and print as time (HH:MM:SS)
                            	    63: FMT_HEXDUMP     equ     FMT_BASE+20     ;pop longword length and longword address, print as hex dump
                            	    64: FMT_BUF         equ     FMT_BASE+21     ;pop longword length and longword address, print as ASCII
                            	    65: FMT_FNAME       equ     FMT_BASE+22     ;pop longword address and print 11 characters as a decoded filename
                            	    66: FMT_ERR         equ     FMT_BASE+23     ;pop word and print description of the error code in the lsb
                            	    67: 
                            	    68: ; option flags for PromptStr
                            	    69: PRbNOECHO       equ     8
                            	    70: PRbNOCTRLCHARS  equ     9
                            	    71: 
                            	    72: PR_NOECHO       equ     (1<<PRbNOECHO)          ;do not echo characters received to output device
                            	    73: PR_NOCTRLCHARS  equ     (1<<PRbNOCTRLCHARS)     ;do not interpret control characters
                            	    74: 

Source: "rom.asm"
                            	     4: 
                            	     5: ROM_VER_MAJ     equ     $0000
                            	     6: ROM_VER_MIN     equ     $9910
                            	     7: ROM_DATE_YEAR   equ     $2020
                            	     8: ROM_DATE_MONTH  equ     $07
                            	     9: ROM_DATE_DAY    equ     $11
                            	    10: 
                            	    11: BAUD_DIV        equ     (((F_CPU*10)/(16*BAUD))+5)/10 ; compute one extra decimal place and round
                            	    12: BAUD_DIV_L      equ     (BAUD_DIV&$FF)
                            	    13: BAUD_DIV_U      equ     ((BAUD_DIV>>8)&$FF)
                            	    14: 
                            	    15:         org     ROM
00:00000000 00F00000        	    16:                 dc.l    INITIAL_SP
00:00000004 000000C0        	    17:                 dc.l    RESET
00:00000008 00001234        	    18:                 dc.l    VEC_BUSFAULT
00:0000000C 0000124C        	    19:                 dc.l    VEC_ADRERROR
00:00000010 00001268        	    20:                 dc.l    VEC_ILLINSTR
00:00000014 0000128A        	    21:                 dc.l    VEC_DIVBY0
00:00000018 000012A4        	    22:                 dc.l    VEC_CHK
00:0000001C 000012B6        	    23:                 dc.l    VEC_TRAPV
00:00000020 000012CA        	    24:                 dc.l    VEC_PRIVVIOL
00:00000024 000012EC        	    25:                 dc.l    VEC_TRACE
00:00000028 00001300        	    26:                 dc.l    VEC_LINE1010
00:0000002C 00001322        	    27:                 dc.l    VEC_LINE1111
00:00000030 00001344        	    28:                 dc.l    VEC_RESERVED    ;12
00:00000034 00001344        	    29:                 dc.l    VEC_RESERVED    ;13
00:00000038 00001344        	    30:                 dc.l    VEC_RESERVED    ;14
00:0000003C 00001362        	    31:                 dc.l    VEC_UNINIVEC
                            	    32:         rept    8
                            	    33:                 dc.l    VEC_RESERVED    ;16-23
                            	    34:         endr
00:00000040 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000044 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000048 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:0000004C 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000050 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000054 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000058 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:0000005C 00001344        	     1R                 dc.l    VEC_RESERVED    ;16-23
                            	     2R         
00:00000060 00001390        	    35:                 dc.l    VEC_SPURIOUS
00:00000064 000011AA        	    36:                 dc.l    VEC_AUTOVEC1
00:00000068 000013B2        	    37:                 dc.l    VEC_AUTOVEC2
00:0000006C 000013CE        	    38:                 dc.l    VEC_AUTOVEC3
00:00000070 000013EA        	    39:                 dc.l    VEC_AUTOVEC4
00:00000074 00001404        	    40:                 dc.l    VEC_AUTOVEC5
00:00000078 0000141E        	    41:                 dc.l    VEC_AUTOVEC6
00:0000007C 00001438        	    42:                 dc.l    VEC_AUTOVEC7
                            	    43:         ; System calls (TRAP #n)
00:00000080 00000404        	    44:                 dc.l    SYS_Exit                ; 0  - return to system
00:00000084 00000408        	    45:                 dc.l    SYS_WaitBtn             ; 1  - wait for button press and release
00:00000088 00000426        	    46:                 dc.l    SYS_OutChar             ; 2  - single character output
00:0000008C 00000430        	    47:                 dc.l    SYS_OutStr              ; 3  - string output
00:00000090 0000044A        	    48:                 dc.l    SYS_OutFmt              ; 4  - formatted string output
00:00000094 000009E0        	    49:                 dc.l    SYS_InChar              ; 5  - single character input
00:00000098 000009EA        	    50:                 dc.l    SYS_PromptStr           ; 6  - prompt for string from input device
00:0000009C 00000A68        	    51:                 dc.l    SYS_ReadSector          ; 7  - read sector from CF card
00:000000A0 00000AC8        	    52:                 dc.l    SYS_ListDirectory       ; 8  - iterate through directory
00:000000A4 00000AD8        	    53:                 dc.l    SYS_FindFile            ; 9  - find named file in directory
00:000000A8 00000ADE        	    54:                 dc.l    SYS_ReadFile            ; 10 - read file from CF card into memory
00:000000AC 00000AE4        	    55:                 dc.l    SYS_GetDateTime         ; 11 - read time and date from real-time clock
00:000000B0 00000B6A        	    56:                 dc.l    SYS_SetDateTime         ; 12 - set real-time clock time and date
00:000000B4 00000BD6        	    57:                 dc.l    SYS_GetSysInfo          ; 13 - return pointer to system info structure
00:000000B8 FFFFFFFF        	    58:                 dc.l    $FFFFFFFF               ; 14 - reserved
00:000000BC 00001452        	    59:                 dc.l    VEC_BREAKPT             ; 15 - break into debugger/monitor
                            	    60: ;-------------------------------------------------------------------------------
                            	    61: RESET:
                            	    62:         ; uart init
00:000000C0 43F900A00000    	    63:                 lea.l   UART,a1
00:000000C6 137C000D0004    	    64:                 move.b  #%00001101,FCR(a1)      ; enable FIFO
00:000000CC 137C00830006    	    65:                 move.b  #%10000011,LCR(a1)      ; 8 data bits, no parity, 1 stop bit, DLAB=1
00:000000D2 12BC000D        	    66:                 move.b  #BAUD_DIV_L,DLL(a1)     ; set divisor latch low byte
00:000000D6 137C00000002    	    67:                 move.b  #BAUD_DIV_U,DLM(a1)     ; set divisor latch high byte
00:000000DC 08A900070006    	    68:                 bclr.b  #7,LCR(a1)              ; disable divisor latch
00:000000E2 4229000E        	    69:                 clr.b   SCR(a1)                 ; clear the scratch register
00:000000E6 137C00010008    	    70:                 move.b  #(1<<MCR_COPI),MCR(a1)  ; SPI COPI idles low
                            	    71:         ; read the button state at launch
00:000000EC 1369000C000E    	    72:                 move.b  MSR(a1),SCR(a1)         ; save the button state into the scratch register
                            	    73: ; Welcome message
                            	    74:                 led_on
00:000000F2 08F9000100A00008	     1M                 bset.b  #MCR_LED,UART+MCR
00:000000FA 41F80218        	    75:                 lea.l   str_startup,a0
                            	    76:                 bl      _printstr
00:000000FE 4DFA0006        	     1M                 lea     (.ret_000009,pc),a6
00:00000102 600001A8        	     2M                 bra     _printstr
                            	     3M .ret_000009:
00:00000106 20390000FFFC    	    77:                 move.l  rom_version,d0
                            	    78:                 bl      _printhexl
00:0000010C 4DFA0006        	     1M                 lea     (.ret_000010,pc),a6
00:00000110 6000016C        	     2M                 bra     _printhexl
                            	     3M .ret_000010:
00:00000114 7020            	    79:                 moveq   #' ',d0
                            	    80:                 tx_char d0,a1
                            	     1M                 tx_wait a1
00:00000116 08290005000A    	     1M .t_000012:          btst.b  #5,LSR(a1)
00:0000011C 67F8            	     2M                 beq     .t_000012
00:0000011E 1280            	     2M                 move.b  d0,THR(a1)
00:00000120 7028            	    81:                 moveq   #'(',d0
                            	    82:                 tx_char d0,a1
                            	     1M                 tx_wait a1
00:00000122 08290005000A    	     1M .t_000014:          btst.b  #5,LSR(a1)
00:00000128 67F8            	     2M                 beq     .t_000014
00:0000012A 1280            	     2M                 move.b  d0,THR(a1)
00:0000012C 20390000FFF8    	    83:                 move.l  rom_date,d0
                            	    84:                 bl      _printhexl
00:00000132 4DFA0006        	     1M                 lea     (.ret_000015,pc),a6
00:00000136 60000146        	     2M                 bra     _printhexl
                            	     3M .ret_000015:
00:0000013A 41F80232        	    85:                 lea.l   str_credits,a0
                            	    86:                 bl      _printstr
00:0000013E 4DFA0006        	     1M                 lea     (.ret_000016,pc),a6
00:00000142 60000168        	     2M                 bra     _printstr
                            	     3M .ret_000016:
                            	    87: ;-------------------------------------------------------------------------------
                            	    88: ; Power-on self-test
                            	    89: ;-------------------------------------------------------------------------------
00:00000146 41F8025A        	    90:                 lea.l   str_ramtest,a0  ;print startup message
                            	    91:                 bl      _printstr
00:0000014A 4DFA0006        	     1M                 lea     (.ret_000017,pc),a6
00:0000014E 6000015C        	     2M                 bra     _printstr
                            	     3M .ret_000017:
                            	    92: ; test RAM
                            	    93: ; unrolled for a bit more speed
                            	    94:         ; write test pattern
00:00000152 41F900E00000    	    95:                 lea.l   RAM,a0          ; start address
00:00000158 47F900F00000    	    96:                 lea.l   RAMEND,a3       ; end address
00:0000015E 203CA5C99C5A    	    97:                 move.l  #$A5C99C5A,d0   ; test word 1
00:00000164 2200            	    98:                 move.l  d0,d1
00:00000166 4681            	    99:                 not.l   d1              ; test word 2
                            	   100: .1:
                            	   101:         rept 8
                            	   102:                 move.l  d0,(a0)+
                            	   103:                 move.l  d1,(a0)+
                            	   104:         endr
00:00000168 20C0            	     1R                 move.l  d0,(a0)+
00:0000016A 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:0000016C 20C0            	     1R                 move.l  d0,(a0)+
00:0000016E 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000170 20C0            	     1R                 move.l  d0,(a0)+
00:00000172 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000174 20C0            	     1R                 move.l  d0,(a0)+
00:00000176 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000178 20C0            	     1R                 move.l  d0,(a0)+
00:0000017A 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:0000017C 20C0            	     1R                 move.l  d0,(a0)+
00:0000017E 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000180 20C0            	     1R                 move.l  d0,(a0)+
00:00000182 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000184 20C0            	     1R                 move.l  d0,(a0)+
00:00000186 20C1            	     2R                 move.l  d1,(a0)+
                            	     3R         
00:00000188 B7C8            	   105:                 cmp.l   a0,a3
00:0000018A 66DC            	   106:                 bne     .1
                            	   107:         ; read back
00:0000018C 41F900E00000    	   108:                 lea.l   RAM,a0          ; start address
00:00000192 47F900F00000    	   109:                 lea.l   RAMEND,a3       ; end address
                            	   110: .2:
                            	   111:         rept 8
                            	   112:                 cmp.l   (a0)+,d0        ; read back longword and compare
                            	   113:                 bne     testfail
                            	   114:                 cmp.l   (a0)+,d1
                            	   115:                 bne     testfail
                            	   116:         endr
00:00000198 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:0000019A 6650            	     2R                 bne     testfail
00:0000019C B298            	     3R                 cmp.l   (a0)+,d1
00:0000019E 664C            	     4R                 bne     testfail
                            	     5R         
00:000001A0 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001A2 6648            	     2R                 bne     testfail
00:000001A4 B298            	     3R                 cmp.l   (a0)+,d1
00:000001A6 6644            	     4R                 bne     testfail
                            	     5R         
00:000001A8 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001AA 6640            	     2R                 bne     testfail
00:000001AC B298            	     3R                 cmp.l   (a0)+,d1
00:000001AE 663C            	     4R                 bne     testfail
                            	     5R         
00:000001B0 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001B2 6638            	     2R                 bne     testfail
00:000001B4 B298            	     3R                 cmp.l   (a0)+,d1
00:000001B6 6634            	     4R                 bne     testfail
                            	     5R         
00:000001B8 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001BA 6630            	     2R                 bne     testfail
00:000001BC B298            	     3R                 cmp.l   (a0)+,d1
00:000001BE 662C            	     4R                 bne     testfail
                            	     5R         
00:000001C0 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001C2 6628            	     2R                 bne     testfail
00:000001C4 B298            	     3R                 cmp.l   (a0)+,d1
00:000001C6 6624            	     4R                 bne     testfail
                            	     5R         
00:000001C8 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001CA 6620            	     2R                 bne     testfail
00:000001CC B298            	     3R                 cmp.l   (a0)+,d1
00:000001CE 661C            	     4R                 bne     testfail
                            	     5R         
00:000001D0 B098            	     1R                 cmp.l   (a0)+,d0        ; read back longword and compare
00:000001D2 6618            	     2R                 bne     testfail
00:000001D4 B298            	     3R                 cmp.l   (a0)+,d1
00:000001D6 6614            	     4R                 bne     testfail
                            	     5R         
00:000001D8 B7C8            	   117:                 cmp.l   a0,a3
00:000001DA 66BC            	   118:                 bne     .2
                            	   119: testpass:
00:000001DC 41F8026A        	   120:                 lea.l   str_testpass,a0
                            	   121:                 bl      _printstr
00:000001E0 4DFA0006        	     1M                 lea     (.ret_000020,pc),a6
00:000001E4 600000C6        	     2M                 bra     _printstr
                            	     3M .ret_000020:
00:000001E8 600000D4        	   122:                 bra     ready
                            	   123: testfail:
00:000001EC 45E8FFFC        	   124:                 lea.l   -4(a0),a2       ; back up to address of failure fail
00:000001F0 41F80272        	   125:                 lea.l   str_testfail,a0 ; print message
                            	   126:                 bl      _printstr
00:000001F4 4DFA0006        	     1M                 lea     (.ret_000021,pc),a6
00:000001F8 600000B2        	     2M                 bra     _printstr
                            	     3M .ret_000021:
00:000001FC 200A            	   127:                 move.l  a2,d0
                            	   128:                 bl      _printhexl
00:000001FE 4DFA0004        	     1M                 lea     (.ret_000022,pc),a6
00:00000202 607A            	     2M                 bra     _printhexl
                            	     3M .ret_000022:
                            	   129: ; flash LED to indicate failure
                            	   130: lockup:         led_tgl
00:00000204 0879000100A00008	     1M                 bchg.b  #MCR_LED,UART+MCR
00:0000020C 203C00008000    	   131:                 move.l  #$8000,d0
00:00000212 51C8FFFE        	   132: .1:             dbra    d0,.1
00:00000216 60EC            	   133:                 bra     lockup
                            	   134: ;-------------------------------------------------------------------------------
                            	   135: str_startup:    asciz   "\n\n68K NANO - ROM VERSION "
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00000218 0A0A36384B204E41	     1M                 dc.b    "\n\n68K NANO - ROM VERSION "
00:00000220 4E4F202D20524F4D
00:00000228 2056455253494F4E
00:00000230 20
                            	     2M                 
00:00000231 00              	     4M                 dc.b    0
                            	     5M                 even
                            	   136: str_credits:    asciz   ")\n(C) 2020 MATT SARNOFF (MSARNOFF.ORG)\n"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00000232 290A284329203230	     1M                 dc.b    ")\n(C) 2020 MATT SARNOFF (MSARNOFF.ORG)\n"
00:0000023A 3230204D41545420
00:00000242 5341524E4F464620
00:0000024A 284D5341524E4F46
00:00000252 462E4F5247290A
                            	     2M                 
00:00000259 00              	     4M                 dc.b    0
                            	     5M                 even
                            	   137: str_ramtest:    asciz   "TESTING RAM..."
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000025A 54455354494E4720	     1M                 dc.b    "TESTING RAM..."
00:00000262 52414D2E2E2E
                            	     2M                 
00:00000268 00              	     4M                 dc.b    0
                            	     5M                 even
                            	   138: str_testpass:   asciz   "PASSED\n"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000026A 5041535345440A  	     1M                 dc.b    "PASSED\n"
                            	     2M                 
00:00000271 00              	     4M                 dc.b    0
                            	     5M                 even
                            	   139: str_testfail:   asciz   "FAILED AT "
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00000272 4641494C45442041	     1M                 dc.b    "FAILED AT "
00:0000027A 5420
                            	     2M                 
00:0000027C 00              	     4M                 dc.b    0
                            	     5M                 even
                            	   140:                 even
                            	   141: ;-------------------------------------------------------------------------------
                            	   142: ; print d0 as 8 hex digits to serial port with base address a1
                            	   143: ; clobbers d1 and d2
                            	   144: ; does not use the stack, suitable for use without RAM
00:0000027E 7207            	   145: _printhexl:     moveq   #7,d1
00:00000280 E998            	   146: .loop:          rol.l   #4,d0           ; nibble to lower 4 bits
00:00000282 3400            	   147:                 move.w  d0,d2
00:00000284 C47C000F        	   148:                 and.w   #%1111,d2       ; isolate nibble
00:00000288 143B2012        	   149:                 move.b  (hexdigits,pc,d2),d2    ; lookup character
                            	   150:                 tx_wait a1              ; print digit
00:0000028C 08290005000A    	     1M .t_000034:          btst.b  #5,LSR(a1)
00:00000292 67F8            	     2M                 beq     .t_000034
00:00000294 1282            	   151:                 move.b  d2,THR(a1)
00:00000296 51C9FFE8        	   152:                 dbra    d1,.loop
                            	   153:                 rl
00:0000029A 4ED6            	     1M                 jmp     (a6)
00:0000029C 3031323334353637	   154: hexdigits:      dc.b    "0123456789ABCDEF"
00:000002A4 3839414243444546
                            	   155: ;-------------------------------------------------------------------------------
                            	   156: ; print null-terminated string in a0 to serial port with base address a1
                            	   157: ; clobbers d0
                            	   158: ; does not use the stack, suitable for use without RAM
00:000002AC 1018            	   159: _printstr:      move.b  (a0)+,d0        ; get byte
00:000002AE 670C            	   160:                 beq     .2              ; found the null?
00:000002B0 08290005000A    	   161: .1:             btst.b  #5,LSR(a1)      ; wait until transmit holding register is empty
00:000002B6 67F8            	   162:                 beq     .1
00:000002B8 1280            	   163:                 move.b  d0,THR(a1)      ; transmit byte
00:000002BA 60F0            	   164:                 bra     _printstr        ; do next character
                            	   165: .2:             rl
00:000002BC 4ED6            	     1M                 jmp     (a6)
                            	   166: 
                            	   167: 
                            	   168: ;-------------------------------------------------------------------------------
                            	   169: ; System is ready, memory is usable
                            	   170: ;-------------------------------------------------------------------------------
                            	   171: ready:
00:000002BE 2E7C00F00000    	   172:                 move.l  #INITIAL_SP,sp  ; reset stack pointer
00:000002C4 23FC0000118600E0	   173:                 move.l  #uart_outchar,OUTCH_VEC ; default i/o is serial port
00:000002CC 0000
00:000002CE 23FC0000119800E0	   174:                 move.l  #uart_inchar,INCH_VEC
00:000002D6 0004
00:000002D8 23FC000014EE00E0	   175:                 move.l  #hexdigits_uc,HEXDIGITS
00:000002E0 0008
00:000002E2 23FC2D3A2C0000E0	   176:                 move.l  #$2d3a2c00,SEPARATORS   ; hyphen, colon, comma as thousands separator
00:000002EA 000C
                            	   177:         ; print system info
                            	   178:                 sys     GetSysInfo
00:000002EC 4E4D            	     1M                 trap    #GetSysInfo
00:000002EE 2F10            	   179:                 move.l  0(a0),-(sp)     ; clock speed
00:000002F0 2F280008        	   180:                 move.l  8(a0),-(sp)     ; ROM size
00:000002F4 2F280004        	   181:                 move.l  4(a0),-(sp)     ; RAM size
00:000002F8 41F81634        	   182:                 lea.l   fmt_sysinfo,a0
                            	   183:                 sys     OutFmt
00:000002FC 4E44            	     1M                 trap    #OutFmt
00:000002FE 4FEF000C        	   184:                 lea.l   12(sp),sp
                            	   185:         ; check for real-time clock
00:00000302 61000E5C        	   186:                 bsr     printtime
                            	   187:         ; enable break interrupt to enter serial loader
00:00000306 137C00040002    	   188:                 move.b  #%00000100,IER(a1)
00:0000030C 46FC2000        	   189:                 move.w  #$2000,sr       ; enable interrupts
                            	   190:         ; try to mount the filesystem on the CF card
00:00000310 6100096C        	   191:                 bsr     fs_mount
00:00000314 671E            	   192:                 beq     .foundcard
                            	   193:         ; error? print message
00:00000316 61000A66        	   194:                 bsr     fs_errorstr
00:0000031A 3F00            	   195:                 move.w  d0,-(sp)
                            	   196:                 litstr  FMT_ERR,"\n"
00:0000031C 41FA0004        	     1M                 lea.l   (.str_000039,pc),a0
00:00000320 6004            	     2M                 bra     .next_000039
                            	     3M .str_000039:
                            	     4M                 rept    2
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00000322 F7              	     1M                 dc.b    FMT_ERR
                            	     2M                 
00:00000323 0A              	     1M                 dc.b    "\n"
                            	     2M                 
00:00000324 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000039:
                            	   197:                 sys     OutFmt
00:00000326 4E44            	     1M                 trap    #OutFmt
00:00000328 544F            	   198:                 addq    #2,sp
00:0000032A 600000D4        	   199:                 bra     idle
                            	   200: .printcardmsg:  sys     OutStr
00:0000032E 4E43            	     1M                 trap    #OutStr
00:00000330 600000CE        	   201:                 bra     idle
                            	   202: .foundcard:     litstr  "CARD DETECTED: ",FMT_U32," KB '",FMT_S,"'\n"
00:00000334 41FA0004        	     1M                 lea.l   (.str_000043,pc),a0
00:00000338 601A            	     2M                 bra     .next_000043
                            	     3M .str_000043:
                            	     4M                 rept    5
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:0000033A 4341524420444554	     1M                 dc.b    "CARD DETECTED: "
00:00000342 45435445443A20
                            	     2M                 
00:00000349 E9              	     1M                 dc.b    FMT_U32
                            	     2M                 
00:0000034A 204B422027      	     1M                 dc.b    " KB '"
                            	     2M                 
00:0000034F E6              	     1M                 dc.b    FMT_S
                            	     2M                 
00:00000350 270A            	     1M                 dc.b    "'\n"
                            	     2M                 
00:00000352 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000043:
00:00000354 487900E0002E    	   203:                 pea     VOLNAME
00:0000035A 203900E00010    	   204:                 move.l  PARTSIZE,d0
00:00000360 E288            	   205:                 lsr.l   #1,d0           ; convert sectors to KB
00:00000362 2F00            	   206:                 move.l  d0,-(sp)
                            	   207:                 sys     OutFmt
00:00000364 4E44            	     1M                 trap    #OutFmt
00:00000366 504F            	   208:                 addq    #8,sp
                            	   209:         ; check the button state at boot (stored in the uart scratch register)
00:00000368 0839000600A0000E	   210:                 btst.b  #MSR_BTN1,UART+SCR
00:00000370 666E            	   211:                 bne     .skipstartup
                            	   212:         ; see if there's a startup file to run
00:00000372 70FF            	   213:                 moveq   #-1,d0          ; TODO fail if binary too big
00:00000374 43F900E00100    	   214:                 lea.l   APPMEMSTART,a1  ; destination
                            	   215:                 litstr  "STARTUP.BIN"   ; startup filename
00:0000037A 41FA0004        	     1M                 lea.l   (.str_000046,pc),a0
00:0000037E 600C            	     2M                 bra     .next_000046
                            	     3M .str_000046:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00000380 535441525455502E	     1M                 dc.b    "STARTUP.BIN"
00:00000388 42494E
                            	     2M                 
00:0000038B 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000046:
                            	   216:                 sys     ReadFile
00:0000038C 4E4A            	     1M                 trap    #ReadFile
00:0000038E 4A00            	   217:                 tst.b   d0
00:00000390 6622            	   218:                 bne     .nostartup
                            	   219:         ; load suceeded, run startup file
                            	   220:                 litstr  "RUNNING STARTUP.BIN\n"
00:00000392 41FA0004        	     1M                 lea.l   (.str_000049,pc),a0
00:00000396 6016            	     2M                 bra     .next_000049
                            	     3M .str_000049:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00000398 52554E4E494E4720	     1M                 dc.b    "RUNNING STARTUP.BIN\n"
00:000003A0 535441525455502E
00:000003A8 42494E0A
                            	     2M                 
00:000003AC 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000049:
                            	   221:                 sys     OutStr
00:000003AE 4E43            	     1M                 trap    #OutStr
00:000003B0 60000E4E        	   222:                 bra     launchapp
                            	   223: 
                            	   224: 
00:000003B4 3F00            	   225: .nostartup:     move.w  d0,-(sp)        ; error number
                            	   226:                 litstr  "CANNOT LOAD STARTUP.BIN - ",FMT_ERR,"\n"
00:000003B6 41FA0004        	     1M                 lea.l   (.str_000052,pc),a0
00:000003BA 601E            	     2M                 bra     .next_000052
                            	     3M .str_000052:
                            	     4M                 rept    3
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:000003BC 43414E4E4F54204C	     1M                 dc.b    "CANNOT LOAD STARTUP.BIN - "
00:000003C4 4F41442053544152
00:000003CC 5455502E42494E20
00:000003D4 2D20
                            	     2M                 
00:000003D6 F7              	     1M                 dc.b    FMT_ERR
                            	     2M                 
00:000003D7 0A              	     1M                 dc.b    "\n"
                            	     2M                 
00:000003D8 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000052:
                            	   227:                 sys     OutFmt
00:000003DA 4E44            	     1M                 trap    #OutFmt
00:000003DC 544F            	   228:                 addq    #2,sp
00:000003DE 6020            	   229:                 bra     idle
                            	   230: 
                            	   231: .skipstartup    litstr  "BYPASSING STARTUP.BIN\n"
00:000003E0 41FA0004        	     1M                 lea.l   (.str_000055,pc),a0
00:000003E4 6018            	     2M                 bra     .next_000055
                            	     3M .str_000055:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:000003E6 425950415353494E	     1M                 dc.b    "BYPASSING STARTUP.BIN\n"
00:000003EE 4720535441525455
00:000003F6 502E42494E0A
                            	     2M                 
00:000003FC 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000055:
                            	   232:                 sys     OutStr
00:000003FE 4E43            	     1M                 trap    #OutStr
                            	   233: idle:
00:00000400 60001826        	   234:                 bra     startshell
                            	   235: ;                 litstr  "WAITING FOR SERIAL DATA.\n"
                            	   236: ;                 sys     OutStr
                            	   237: ;         ; slowly fade the LED in and out to indicate we're ready
                            	   238: ; animate_led:
                            	   239: ; fadespeed       equ     6
                            	   240: ;                 moveq   #0,d1  ; duty cycle
                            	   241: ;                 moveq   #fadespeed,d2  ; number of periods with given duty cycle
                            	   242: ;                 led_on
                            	   243: ; .cycle:         move.l  #255,d0
                            	   244: ;                 led_tgl
                            	   245: ; .loop:          cmp.b   d0,d1   ; invert LED waveform when count == duty cycle value
                            	   246: ;                 bne     .1
                            	   247: ;                 led_tgl
                            	   248: ; .1:             dbra    d0,.loop
                            	   249: ;                 dbra    d2,.cycle
                            	   250: ;         ; increment duty cycle
                            	   251: ;                 addq    #1,d1
                            	   252: ;         ; when duty cycle == 0, invert waveform (change fade direction)
                            	   253: ;                 cmp.b   #0,d1
                            	   254: ;                 bne     .2
                            	   255: ;                 led_tgl
                            	   256: ; .2:             moveq   #fadespeed,d2
                            	   257: ;                 bra     .cycle
                            	   258: 
                            	   259: ;===============================================================================
                            	   260: ; Syscalls
                            	   261: ;===============================================================================
                            	   262: 
                            	   263: ; Exit - return to system
                            	   264: ; Arguments:    none
                            	   265: SYS_Exit:
00:00000404 6000FEB8        	   266:                 bra     ready
                            	   267: 
                            	   268: 
                            	   269: ; WaitBtn - wait for button press and release
                            	   270: ; Arguments:    none
                            	   271: SYS_WaitBtn:
00:00000408 43F900A00000    	   272:                 lea.l   UART,a1
00:0000040E 08290006000C    	   273: .waitpress:     btst    #MSR_BTN1,MSR(a1)       ; wait for button press
00:00000414 67F8            	   274:                 beq     .waitpress
00:00000416 70FF            	   275:                 moveq   #-1,d0
00:00000418 51C8FFFE        	   276: .debounce:      dbra    d0,.debounce            ; wait for debounce
00:0000041C 08290006000C    	   277: .waitrelease:   btst    #MSR_BTN1,MSR(a1)       ; wait for button release
00:00000422 66F8            	   278:                 bne     .waitrelease
00:00000424 4E73            	   279:                 rte
                            	   280: 
                            	   281: ; OutChar - write one byte to the current output device
                            	   282: ; Arguments:    D0.B - character
                            	   283: SYS_OutChar:
00:00000426 227900E00000    	   284:                 move.l  OUTCH_VEC,a1
00:0000042C 4E91            	   285:                 jsr     (a1)
00:0000042E 4E73            	   286:                 rte
                            	   287: 
                            	   288: ; OutStr - write null-terminated string to the serial port
                            	   289: ; Arguments:    A0.L - pointer to null-terminated string
                            	   290: SYS_OutStr:
                            	   291:                 pushm   a2-a3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000430 48E70030        	     4M                 movem.l a2-a3,-(sp)
00:00000434 2448            	   292:                 move.l  a0,a2
00:00000436 267900E00000    	   293:                 move.l  OUTCH_VEC,a3
00:0000043C 101A            	   294: .1:             move.b  (a2)+,d0        ; get byte
00:0000043E 6704            	   295:                 beq     .2              ; found the null?
00:00000440 4E93            	   296:                 jsr     (a3)
00:00000442 60F8            	   297:                 bra     .1
                            	   298: .2:             popm    a2-a3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000444 245F265F        	     4M                 movem.l (sp)+,a2-a3
00:00000448 4E73            	   299:                 rte
                            	   300: 
                            	   301: ; OutFmt - write formatted string to the current output device
                            	   302: ; Arguments:    A0.L - pointer to null-terminated format string
                            	   303: ;               format arguments on stack (caller is responsible for cleanup)
                            	   304: SYS_OutFmt:
                            	   305:                 pushm   d2/a2-a6
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:0000044A 48E7203E        	     4M                 movem.l d2/a2-a6,-(sp)
00:0000044E 4DEF001E        	   306:                 lea.l   30(sp),a6       ; a6 points to argument list on stack
00:00000452 2448            	   307:                 move.l  a0,a2
00:00000454 267900E00000    	   308:                 move.l  OUTCH_VEC,a3    ; pointer to output routine
00:0000045A 2A7900E00008    	   309:                 move.l  HEXDIGITS,a5    ; pointer tp digit table
00:00000460 7000            	   310: fmtchar:        moveq   #0,d0           ; clear upper bytes
00:00000462 101A            	   311:                 move.b  (a2)+,d0        ; get byte
00:00000464 D040            	   312:                 add.w   d0,d0           ; multiply by 2 to get table offset
00:00000466 323B0006        	   313:                 move.w  fmt_jumptable(pc,d0.w),d1
00:0000046A 4EFB1002        	   314:                 jmp     fmt_jumptable(pc,d1.w)
                            	   315: 
00:0000046E 01F0            	   316: fmt_jumptable:  dc.w    .fmt_nullbyte-fmt_jumptable
                            	   317:         rept    FMT_BASE-1
                            	   318:                 dc.w    .fmt_literalchar-fmt_jumptable
                            	   319:         endr
00:00000470 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000472 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000474 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000476 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000478 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000047A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000047C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000047E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000480 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000482 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000484 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000486 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000488 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000048A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000048C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000048E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000490 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000492 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000494 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000496 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000498 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000049A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000049C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000049E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004A0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004A2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004A4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004A6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004A8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004AA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004AC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004AE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004B0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004B2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004B4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004B6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004B8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004BA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004BC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004BE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004C0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004C2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004C4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004C6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004C8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004CA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004CC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004CE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004D0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004D2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004D4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004D6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004D8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004DA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004DC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004DE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004E0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004E2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004E4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004E6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004E8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004EA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004EC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004EE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004F0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004F2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004F4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004F6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004F8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004FA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004FC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000004FE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000500 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000502 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000504 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000506 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000508 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000050A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000050C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000050E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000510 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000512 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000514 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000516 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000518 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000051A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000051C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000051E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000520 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000522 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000524 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000526 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000528 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000052A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000052C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000052E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000530 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000532 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000534 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000536 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000538 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000053A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000053C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000053E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000540 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000542 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000544 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000546 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000548 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000054A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000054C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000054E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000550 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000552 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000554 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000556 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000558 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000055A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000055C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000055E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000560 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000562 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000564 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000566 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000568 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000056A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000056C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000056E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000570 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000572 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000574 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000576 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000578 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000057A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000057C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000057E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000580 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000582 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000584 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000586 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000588 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000058A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000058C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000058E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000590 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000592 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000594 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000596 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000598 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000059A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000059C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000059E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005A0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005A2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005A4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005A6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005A8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005AA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005AC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005AE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005B0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005B2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005B4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005B6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005B8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005BA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005BC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005BE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005C0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005C2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005C4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005C6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005C8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005CA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005CC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005CE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005D0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005D2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005D4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005D6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005D8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005DA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005DC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005DE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005E0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005E2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005E4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005E6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005E8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005EA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005EC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005EE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005F0 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005F2 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005F4 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005F6 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005F8 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005FA 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005FC 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:000005FE 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000600 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000602 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000604 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000606 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000608 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000060A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000060C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000060E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000610 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000612 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000614 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000616 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000618 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000061A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000061C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000061E 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000620 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000622 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000624 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000626 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:00000628 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000062A 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000062C 01F6            	     1R                 dc.w    .fmt_literalchar-fmt_jumptable
                            	     2R         
00:0000062E 01FE            	   320:                 dc.w    .fmt_char-fmt_jumptable
00:00000630 0206            	   321:                 dc.w    .fmt_char2-fmt_jumptable
00:00000632 0214            	   322:                 dc.w    .fmt_char4-fmt_jumptable
00:00000634 0224            	   323:                 dc.w    .fmt_hex8-fmt_jumptable
00:00000636 0234            	   324:                 dc.w    .fmt_hex16-fmt_jumptable
00:00000638 022E            	   325:                 dc.w    .fmt_hex32-fmt_jumptable
00:0000063A 02F4            	   326:                 dc.w    .fmt_str-fmt_jumptable
00:0000063C 0348            	   327:                 dc.w    .fmt_u8-fmt_jumptable
00:0000063E 03AC            	   328:                 dc.w    .fmt_u16-fmt_jumptable
00:00000640 0360            	   329:                 dc.w    .fmt_u32-fmt_jumptable
00:00000642 0332            	   330:                 dc.w    .fmt_d8-fmt_jumptable
00:00000644 03A0            	   331:                 dc.w    .fmt_d16-fmt_jumptable
00:00000646 03C8            	   332:                 dc.w    .fmt_d32-fmt_jumptable
00:00000648 0350            	   333:                 dc.w    .fmt_z8-fmt_jumptable
00:0000064A 035A            	   334:                 dc.w    .fmt_z16-fmt_jumptable
00:0000064C 03D4            	   335:                 dc.w    .fmt_z32-fmt_jumptable
00:0000064E 04BE            	   336:                 dc.w    .fmt_srbits-fmt_jumptable
00:00000650 0500            	   337:                 dc.w    .fmt_fltbits-fmt_jumptable
00:00000652 023E            	   338:                 dc.w    .fmt_date-fmt_jumptable
00:00000654 0266            	   339:                 dc.w    .fmt_time-fmt_jumptable
00:00000656 028A            	   340:                 dc.w    .fmt_hexdump-fmt_jumptable
00:00000658 02E0            	   341:                 dc.w    .fmt_buf-fmt_jumptable
00:0000065A 0300            	   342:                 dc.w    .fmt_fname-fmt_jumptable
00:0000065C 031E            	   343:                 dc.w    .fmt_err-fmt_jumptable
                            	   344: 
                            	   345: .fmt_nullbyte:
                            	   346:                 popm    d2/a2-a6
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:0000065E 4CDF7C04        	     4M                 movem.l (sp)+,d2/a2-a6
00:00000662 4E73            	   347:                 rte
                            	   348: .fmt_literalchar:
00:00000664 E248            	   349:                 lsr.w   #1,d0           ; divide by 2 to get original char
00:00000666 4E93            	   350:                 jsr     (a3)
00:00000668 6000FDF6        	   351:                 bra     fmtchar
                            	   352: .fmt_char:
00:0000066C 301E            	   353:                 move.w  (a6)+,d0        ; get char from stack
00:0000066E 4E93            	   354:                 jsr     (a3)
00:00000670 6000FDEE        	   355:                 bra     fmtchar
                            	   356: .fmt_char2:
00:00000674 301E            	   357:                 move.w  (a6)+,d0        ; get chars from stack
00:00000676 E058            	   358: .1:             ror.w   #8,d0           ; print msb first
00:00000678 4E93            	   359:                 jsr     (a3)
00:0000067A E058            	   360:                 ror.w   #8,d0
00:0000067C 4E93            	   361:                 jsr     (a3)            ; print lsb
00:0000067E 6000FDE0        	   362:                 bra     fmtchar
                            	   363: .fmt_char4:
00:00000682 201E            	   364:                 move.l  (a6)+,d0        ; get chars from stack
00:00000684 4840            	   365:                 swap    d0              ; print msw first
00:00000686 E058            	   366:                 ror.w   #8,d0           ; print msb of msw
00:00000688 4E93            	   367:                 jsr     (a3)
00:0000068A E058            	   368:                 ror.w   #8,d0
00:0000068C 4E93            	   369:                 jsr     (a3)            ; print lsb of msw
00:0000068E 4840            	   370:                 swap    d0
00:00000690 60E4            	   371:                 bra     .1
                            	   372: 
00:00000692 301E            	   373: .fmt_hex8:      move.w  (a6)+,d0        ; get byte from stack
00:00000694 48780460        	   374:                 pea     fmtchar         ; tail call optimization
00:00000698 60000312        	   375:                 bra     printhexbyte
                            	   376: 
00:0000069C 301E            	   377: .fmt_hex32:     move.w  (a6)+,d0        ; get longword from stack
00:0000069E 61000326        	   378:                 bsr     printhexword
                            	   379:                 ; fall through
00:000006A2 301E            	   380: .fmt_hex16:     move.w  (a6)+,d0        ; get word from stack
00:000006A4 48780460        	   381:                 pea     fmtchar
00:000006A8 6000031C        	   382:                 bra     printhexword
                            	   383: 
00:000006AC 301E            	   384: .fmt_date:      move.w  (a6)+,d0        ; get years
00:000006AE 0880000F        	   385:                 bclr.l  #15,d0          ; make sure "time not set" bit is clear
00:000006B2 49F900E0000C    	   386:                 lea.l   DATE_SEP,a4
00:000006B8 6100030C        	   387:                 bsr     printhexword    ; print years
00:000006BC 1014            	   388:                 move.b  (a4),d0         ; print date separator
00:000006BE 4E93            	   389:                 jsr     (a3)
00:000006C0 101E            	   390:                 move.b  (a6)+,d0        ; get month
00:000006C2 610002E8        	   391:                 bsr     printhexbyte    ; print month
00:000006C6 1014            	   392:                 move.b  (a4),d0         ; print date separator
00:000006C8 4E93            	   393:                 jsr     (a3)
00:000006CA 101E            	   394:                 move.b  (a6)+,d0        ; get date
00:000006CC 48780460        	   395:                 pea     fmtchar
00:000006D0 600002DA        	   396:                 bra     printhexbyte    ; print date
                            	   397: 
00:000006D4 301E            	   398: .fmt_time:      move.w  (a6)+,d0        ; get weekday/hour
00:000006D6 49F900E0000D    	   399:                 lea.l   TIME_SEP,a4
00:000006DC 610002CE        	   400:                 bsr     printhexbyte    ; only print lsb (hour)
00:000006E0 1014            	   401:                 move.b  (a4),d0         ; print time separator
00:000006E2 4E93            	   402:                 jsr     (a3)
00:000006E4 101E            	   403:                 move.b  (a6)+,d0        ; get minute
00:000006E6 610002C4        	   404:                 bsr     printhexbyte
00:000006EA 1014            	   405:                 move.b  (a4),d0         ; print time separator
00:000006EC 4E93            	   406:                 jsr     (a3)
00:000006EE 101E            	   407:                 move.b  (a6)+,d0        ; get second
00:000006F0 48780460        	   408:                 pea     fmtchar
00:000006F4 600002B6        	   409:                 bra     printhexbyte
                            	   410: 
00:000006F8 285E            	   411: .fmt_hexdump:   move.l  (a6)+,a4        ; get string address
00:000006FA 7400            	   412:                 moveq   #0,d2           ; initialize byte count to 0
00:000006FC B496            	   413: .hexdumploop:   cmp.l   (a6),d2
00:000006FE 672E            	   414:                 beq     .dumpend
00:00000700 700F            	   415:                 moveq   #$0F,d0         ; lower 4 bits of count equal 0?
00:00000702 C002            	   416:                 and.b   d2,d0
00:00000704 661A            	   417:                 bne     .midline
00:00000706 700A            	   418:                 moveq   #$0a,d0         ; print newline
00:00000708 4E93            	   419:                 jsr     (a3)
00:0000070A 2002            	   420:                 move.l  d2,d0           ; print byte offset as 8 hex digits
00:0000070C 4840            	   421:                 swap    d0
00:0000070E 610002B6        	   422:                 bsr     printhexword    ; upper word
00:00000712 3002            	   423:                 move.w  d2,d0           ; lower word
00:00000714 610002B0        	   424:                 bsr     printhexword
00:00000718 703A            	   425:                 moveq   #':',d0         ; print colon
00:0000071A 4E93            	   426:                 jsr     (a3)
00:0000071C 7020            	   427:                 moveq   #' ',d0         ; print space
00:0000071E 4E93            	   428:                 jsr     (a3)
                            	   429: 
00:00000720 101C            	   430: .midline:       move.b  (a4)+,d0
00:00000722 61000288        	   431:                 bsr     printhexbyte    ; print byte
00:00000726 7020            	   432:                 moveq   #' ',d0         ; print space
00:00000728 4E93            	   433:                 jsr     (a3)
00:0000072A 5282            	   434:                 addq.l  #1,d2           ; increment byte count
00:0000072C 60CE            	   435:                 bra     .hexdumploop
                            	   436: .dumpend:
                            	   437:         ; pad out the final line
00:0000072E 4442            	   438:                 neg.w   d2
00:00000730 C47C000F        	   439:                 and.w   #$000F,d2
00:00000734 670E            	   440:                 beq     .nopad
00:00000736 5342            	   441:                 subq    #1,d2
00:00000738 7020            	   442: .padloop:       moveq   #' ',d0         ; three spaces
00:0000073A 4E93            	   443:                 jsr     (a3)
00:0000073C 4E93            	   444:                 jsr     (a3)
00:0000073E 4E93            	   445:                 jsr     (a3)
00:00000740 51CAFFF6        	   446:                 dbra    d2,.padloop
00:00000744 584E            	   447: .nopad:         addq    #4,a6           ; remove count
00:00000746 700A            	   448:                 moveq   #$0a,d0         ; print final newline
00:00000748 48780460        	   449:                 pea     fmtchar
00:0000074C 4ED3            	   450:                 jmp     (a3)
                            	   451: 
00:0000074E 285E            	   452: .fmt_buf:       move.l  (a6)+,a4        ; get buffer address
00:00000750 241E            	   453:                 move.l  (a6)+,d2        ; get number of bytes to print
00:00000752 6700FD0C        	   454:                 beq     fmtchar         ; do nothing if zero
00:00000756 101C            	   455: .bufloop:       move.b  (a4)+,d0        ; get byte
00:00000758 4E93            	   456:                 jsr     (a3)
00:0000075A 5382            	   457:                 subq.l  #1,d2
00:0000075C 66F8            	   458:                 bne     .bufloop
00:0000075E 6000FD00        	   459:                 bra     fmtchar
                            	   460: 
00:00000762 285E            	   461: .fmt_str:       move.l  (a6)+,a4        ; get string address from stack
00:00000764 101C            	   462: .strloop:       move.b  (a4)+,d0        ; get byte
00:00000766 6700FCF8        	   463:                 beq     fmtchar         ; found the null? done
00:0000076A 4E93            	   464:                 jsr     (a3)
00:0000076C 60F6            	   465:                 bra     .strloop
                            	   466: 
00:0000076E 205E            	   467: .fmt_fname:     move.l  (a6)+,a0        ; get string address
00:00000770 4FEFFFF2        	   468:                 lea.l   -14(sp),sp      ; allocate stack space for filename (only need 13 bytes, but sp must stay word-
00:00000774 224F            	   469:                 move.l  sp,a1
00:00000776 61000950        	   470:                 bsr     fname_decode
00:0000077A 2849            	   471:                 move.l  a1,a4           ; decoded string address
00:0000077C 101C            	   472: .fnameloop:     move.b  (a4)+,d0        ; get byte
00:0000077E 6704            	   473:                 beq     .fnamedone      ; found the null? done
00:00000780 4E93            	   474:                 jsr     (a3)
00:00000782 60F8            	   475:                 bra     .fnameloop
00:00000784 4FEF000E        	   476: .fnamedone:     lea.l   14(sp),sp       ; remove temporary string from stack
00:00000788 6000FCD6        	   477:                 bra     fmtchar
                            	   478: 
00:0000078C 301E            	   479: .fmt_err:       move.w  (a6)+,d0        ; get error number from stack
00:0000078E 610005EE        	   480:                 bsr     fs_errorstr
00:00000792 6704            	   481:                 beq     .othererr
00:00000794 2848            	   482:                 move.l  a0,a4           ; valid error msg? print it
00:00000796 60CC            	   483:                 bra     .strloop
                            	   484:         ; no error message? just print error number as hex
00:00000798 48780460        	   485: .othererr:      pea     fmtchar         ; tail call optimization
00:0000079C 6000020E        	   486:                 bra     printhexbyte
                            	   487: 
00:000007A0 341E            	   488: .fmt_d8:        move.w  (a6)+,d2        ; get word from stack
00:000007A2 4882            	   489:                 ext.w   d2              ; check sign bit
00:000007A4 6A000082        	   490:                 bpl     .dec8           ; positive? just use the unsigned routine
00:000007A8 702D            	   491:                 moveq   #'-',d0         ; print leading minus
00:000007AA 4E93            	   492:                 jsr     (a3)
00:000007AC 4402            	   493:                 neg.b   d2              ; negate and jump to unsigned routine
00:000007AE C4BC000000FF    	   494:                 and.l   #$FF,d2         ; make sure upper bytes are clear
00:000007B4 6072            	   495:                 bra     .dec8
                            	   496: 
00:000007B6 341E            	   497: .fmt_u8:        move.w  (a6)+,d2        ; get word from stack
00:000007B8 024200FF        	   498:                 andi.w  #$00FF,d2       ; clear upper byte of word
00:000007BC 606A            	   499:                 bra     .dec8
                            	   500: 
00:000007BE 341E            	   501: .fmt_z8:        move.w  (a6)+,d2        ; get word from stack
00:000007C0 024200FF        	   502:                 andi.w  #$00FF,d2       ; clear upper byte of word
00:000007C4 600000BC        	   503:                 bra     .hundreds
                            	   504: 
00:000007C8 341E            	   505: .fmt_z16:       move.w  (a6)+,d2        ; get word from stack
00:000007CA 6000008A        	   506:                 bra     .tthousands
                            	   507: 
00:000007CE 241E            	   508: .fmt_u32:       move.l  (a6)+,d2        ; get longword from stack
00:000007D0 B4BC0000FFFF    	   509: .dec32:         cmp.l   #$FFFF,d2
00:000007D6 6344            	   510:                 bls     .dec16          ; if < 65536, use 16-bit routine
00:000007D8 B4BC3B9ACA00    	   511:                 cmp.l   #1000000000,d2
00:000007DE 640000C8        	   512:                 bcc     .billions
00:000007E2 B4BC05F5E100    	   513:                 cmp.l   #100000000,d2
00:000007E8 640000DA        	   514:                 bcc     .hmillions
00:000007EC B4BC00989680    	   515:                 cmp.l   #10000000,d2
00:000007F2 640000E2        	   516:                 bcc     .tmillions
00:000007F6 B4BC000F4240    	   517:                 cmp.l   #1000000,d2
00:000007FC 640000EA        	   518:                 bcc     .millions
00:00000800 B4BC000186A0    	   519:                 cmp.l   #100000,d2
00:00000806 640000FC        	   520:                 bcc     .hthousands
00:0000080A 6000010A        	   521:                 bra     .tthousands_l   ; between 65536 and 99999 inclusive
                            	   522: 
00:0000080E 341E            	   523: .fmt_d16:       move.w  (a6)+,d2        ; get word from stack
00:00000810 6A0A            	   524:                 bpl     .dec16          ; positive? just use the unsigned routine
00:00000812 702D            	   525:                 moveq   #'-',d0         ; print leading minus
00:00000814 4E93            	   526:                 jsr     (a3)
00:00000816 4442            	   527:                 neg.w   d2              ; negate and jump to unsigned routine
00:00000818 6002            	   528:                 bra     .dec16
                            	   529: 
00:0000081A 341E            	   530: .fmt_u16:       move.w  (a6)+,d2        ; get word from stack
00:0000081C B47C2710        	   531: .dec16:         cmp.w   #10000,d2
00:00000820 6434            	   532:                 bcc     .tthousands
00:00000822 B47C03E8        	   533:                 cmp.w   #1000,d2
00:00000826 6440            	   534:                 bcc     .thousands
00:00000828 B47C0064        	   535: .dec8:          cmp.w   #100,d2
00:0000082C 6454            	   536:                 bcc     .hundreds
00:0000082E B47C000A        	   537:                 cmp.w   #10,d2
00:00000832 645C            	   538:                 bcc     .tens
00:00000834 6068            	   539:                 bra     .ones
                            	   540: 
00:00000836 241E            	   541: .fmt_d32:       move.l  (a6)+,d2        ; get longword from stack
00:00000838 6A96            	   542:                 bpl     .dec32          ; positive? just use the unsigned routine
00:0000083A 702D            	   543:                 moveq   #'-',d0         ; print leading minus
00:0000083C 4E93            	   544:                 jsr     (a3)
00:0000083E 4482            	   545:                 neg.l   d2              ; negate and jump to unsigned routine
00:00000840 608E            	   546:                 bra     .dec32
                            	   547: 
00:00000842 241E            	   548: .fmt_z32:       move.l  (a6)+,d2        ; get longword from stack
00:00000844 B4BC0000FFFF    	   549:                 cmp.l   #$FFFF,d2
00:0000084A 625C            	   550:                 bhi     .billions       ; if < 65536, print leading zeros and fall through to 16-bit routine
00:0000084C 7030            	   551:                 moveq   #'0',d0
00:0000084E 4E93            	   552:                 jsr     (a3)
00:00000850 4E93            	   553:                 jsr     (a3)
00:00000852 4E93            	   554:                 jsr     (a3)
00:00000854 4E93            	   555:                 jsr     (a3)
00:00000856 223C00002710    	   556: .tthousands:    move.l  #10000,d1
00:0000085C 702F            	   557:                 moveq   #'/',d0
00:0000085E 5240            	   558: .loop10000:     addq    #1,d0
00:00000860 9441            	   559:                 sub.w   d1,d2
00:00000862 64FA            	   560:                 bcc     .loop10000
00:00000864 D441            	   561:                 add.w   d1,d2
00:00000866 4E93            	   562:                 jsr     (a3)
00:00000868 323C03E8        	   563: .thousands:     move.w  #1000,d1
00:0000086C 702F            	   564:                 moveq   #'/',d0
00:0000086E 5240            	   565: .loop1000:      addq    #1,d0
00:00000870 9441            	   566:                 sub.w   d1,d2
00:00000872 64FA            	   567:                 bcc     .loop1000
00:00000874 D441            	   568:                 add.w   d1,d2
00:00000876 4E93            	   569:                 jsr     (a3)
                            	   570: 
00:00000878 103900E0000E    	   571:                 move.b  THOUSANDS_SEP,d0
00:0000087E 6702            	   572:                 beq     .hundreds
00:00000880 4E93            	   573:                 jsr     (a3)
                            	   574: 
00:00000882 7264            	   575: .hundreds:      moveq   #100,d1
00:00000884 702F            	   576:                 moveq   #'/',d0
00:00000886 5240            	   577: .loop100:       addq    #1,d0
00:00000888 9441            	   578:                 sub.w   d1,d2
00:0000088A 64FA            	   579:                 bcc     .loop100
00:0000088C D441            	   580:                 add.w   d1,d2
00:0000088E 4E93            	   581:                 jsr     (a3)
00:00000890 720A            	   582: .tens:          moveq   #10,d1
00:00000892 702F            	   583:                 moveq   #'/',d0
00:00000894 5240            	   584: .loop10:        addq    #1,d0
00:00000896 9441            	   585:                 sub.w   d1,d2
00:00000898 64FA            	   586:                 bcc     .loop10
00:0000089A D441            	   587:                 add.w   d1,d2
00:0000089C 4E93            	   588:                 jsr     (a3)
00:0000089E 7030            	   589: .ones:          moveq   #'0',d0
00:000008A0 D002            	   590:                 add.b   d2,d0
00:000008A2 4E93            	   591:                 jsr     (a3)
00:000008A4 6000FBBA        	   592:                 bra     fmtchar
00:000008A8 223C3B9ACA00    	   593: .billions:      move.l  #1000000000,d1
00:000008AE 702F            	   594:                 moveq   #'/',d0
00:000008B0 5240            	   595: .loop1e9:       addq    #1,d0
00:000008B2 9481            	   596:                 sub.l   d1,d2
00:000008B4 64FA            	   597:                 bcc     .loop1e9
00:000008B6 D481            	   598:                 add.l   d1,d2
00:000008B8 4E93            	   599:                 jsr     (a3)
                            	   600: 
00:000008BA 103900E0000E    	   601:                 move.b  THOUSANDS_SEP,d0
00:000008C0 6702            	   602:                 beq     .hmillions
00:000008C2 4E93            	   603:                 jsr     (a3)
                            	   604: 
00:000008C4 223C05F5E100    	   605: .hmillions:     move.l  #100000000,d1
00:000008CA 702F            	   606:                 moveq   #'/',d0
00:000008CC 5240            	   607: .loop1e8:       addq    #1,d0
00:000008CE 9481            	   608:                 sub.l   d1,d2
00:000008D0 64FA            	   609:                 bcc     .loop1e8
00:000008D2 D481            	   610:                 add.l   d1,d2
00:000008D4 4E93            	   611:                 jsr     (a3)
00:000008D6 223C00989680    	   612: .tmillions:     move.l  #10000000,d1
00:000008DC 702F            	   613:                 moveq   #'/',d0
00:000008DE 5240            	   614: .loop1e7:       addq    #1,d0
00:000008E0 9481            	   615:                 sub.l   d1,d2
00:000008E2 64FA            	   616:                 bcc     .loop1e7
00:000008E4 D481            	   617:                 add.l   d1,d2
00:000008E6 4E93            	   618:                 jsr     (a3)
                            	   619: 
00:000008E8 223C000F4240    	   620: .millions:      move.l  #1000000,d1
00:000008EE 702F            	   621:                 moveq   #'/',d0
00:000008F0 5240            	   622: .loop1e6:       addq    #1,d0
00:000008F2 9481            	   623:                 sub.l   d1,d2
00:000008F4 64FA            	   624:                 bcc     .loop1e6
00:000008F6 D481            	   625:                 add.l   d1,d2
00:000008F8 4E93            	   626:                 jsr     (a3)
                            	   627: 
00:000008FA 103900E0000E    	   628:                 move.b  THOUSANDS_SEP,d0
00:00000900 6702            	   629:                 beq     .hthousands
00:00000902 4E93            	   630:                 jsr     (a3)
                            	   631: 
00:00000904 223C000186A0    	   632: .hthousands:    move.l  #100000,d1
00:0000090A 702F            	   633:                 moveq   #'/',d0
00:0000090C 5240            	   634: .loop1e5:       addq    #1,d0
00:0000090E 9481            	   635:                 sub.l   d1,d2
00:00000910 64FA            	   636:                 bcc     .loop1e5
00:00000912 D481            	   637:                 add.l   d1,d2
00:00000914 4E93            	   638:                 jsr     (a3)
00:00000916 223C00002710    	   639: .tthousands_l:  move.l  #10000,d1
00:0000091C 702F            	   640:                 moveq   #'/',d0
00:0000091E 5240            	   641: .loop1e4:       addq    #1,d0
00:00000920 9481            	   642:                 sub.l   d1,d2
00:00000922 64FA            	   643:                 bcc     .loop1e4
00:00000924 D481            	   644:                 add.l   d1,d2
00:00000926 4E93            	   645:                 jsr     (a3)
00:00000928 6000FF3E        	   646:                 bra     .thousands
                            	   647: 
00:0000092C 341E            	   648: .fmt_srbits:    move.w  (a6)+,d2        ; get word from stack
00:0000092E 49F8098E        	   649:                 lea.l   .srflagchars,a4
00:00000932 0802000F        	   650:                 btst.l  #15,d2          ; trace flag
00:00000936 6168            	   651:                 bsr     printflag
00:00000938 0802000D        	   652:                 btst.l  #13,d2          ; supervisor flag
00:0000093C 6162            	   653:                 bsr     printflag
00:0000093E 3002            	   654:                 move.w  d2,d0
00:00000940 E048            	   655:                 lsr.w   #8,d0           ; get interrupt priority level
00:00000942 C03C0007        	   656:                 and.b   #7,d0           ; isolate 3 bits
00:00000946 D03C0030        	   657:                 add.b   #'0',d0         ; convert to ASCII digit
00:0000094A 4E93            	   658:                 jsr     (a3)
00:0000094C 08020004        	   659:                 btst.l  #4,d2           ; extend flag
00:00000950 614E            	   660:                 bsr     printflag
00:00000952 08020003        	   661:                 btst.l  #3,d2           ; negative flag
00:00000956 6148            	   662:                 bsr     printflag
00:00000958 08020002        	   663:                 btst.l  #2,d2           ; zero flag
00:0000095C 6142            	   664:                 bsr     printflag
00:0000095E 08020001        	   665:                 btst.l  #1,d2           ; overflow flag
00:00000962 613C            	   666:                 bsr     printflag
00:00000964 08020000        	   667:                 btst.l  #0,d2           ; carry flag
00:00000968 6136            	   668:                 bsr     printflag
00:0000096A 6000FAF4        	   669:                 bra     fmtchar
                            	   670: 
00:0000096E 341E            	   671: .fmt_fltbits:   move.w  (a6)+,d2        ; get word from stack
00:00000970 49F8099C        	   672:                 lea.l   .fltflagchars,a4
00:00000974 08020004        	   673:                 btst.l  #4,d2           ; read/write flag
00:00000978 6126            	   674:                 bsr     printflag
00:0000097A 08020003        	   675:                 btst.l  #3,d2           ; instruction/not-instruction flag
00:0000097E 6120            	   676:                 bsr     printflag
00:00000980 C43C0007        	   677:                 and.b   #7,d2           ; isolate 3 bits of function code
00:00000984 7030            	   678:                 moveq   #'0',d0
00:00000986 D002            	   679:                 add.b   d2,d0           ; convert function code to ASCII digit
00:00000988 4E93            	   680:                 jsr     (a3)
00:0000098A 6000FAD4        	   681:                 bra     fmtchar
                            	   682: 
00:0000098E 2D542D532D582D4E	   683: .srflagchars:   dc.b    "-T-S-X-N-Z-V-C"
00:00000996 2D5A2D562D43
00:0000099C 5752494E        	   684: .fltflagchars:  dc.b    "WRIN"
                            	   685:                 even
                            	   686: 
00:000009A0 6704            	   687: printflag:      beq     .flag0
00:000009A2 301C            	   688: .flag1:         move.w  (a4)+,d0
00:000009A4 4ED3            	   689:                 jmp     (a3)
00:000009A6 101C            	   690: .flag0:         move.b  (a4)+,d0
00:000009A8 524C            	   691:                 addq    #1,a4
00:000009AA 4ED3            	   692:                 jmp     (a3)
                            	   693: 
                            	   694: 
00:000009AC 0280000000FF    	   695: printhexbyte:   andi.l  #$00FF,d0       ; isolate lower byte
00:000009B2 E098            	   696:                 ror.l   #8,d0           ; and move it to the upper byte
00:000009B4 E998            	   697: _lsb:           rol.l   #4,d0           ; get upper nibble
00:000009B6 10350000        	   698:                 move.b  (a5,d0.w),d0    ; digit lookup in table
00:000009BA 4E93            	   699:                 jsr     (a3)
00:000009BC 4240            	   700:                 clr.w   d0
00:000009BE E998            	   701:                 rol.l   #4,d0           ; get lower nibble of upper byte
00:000009C0 10350000        	   702:                 move.b  (a5,d0.w),d0    ; digit lookup in table
00:000009C4 4ED3            	   703:                 jmp     (a3)
                            	   704: 
                            	   705: 
00:000009C6 4840            	   706: printhexword:   swap    d0              ; move to upper word
00:000009C8 4240            	   707:                 clr.w   d0              ; clear lower word
00:000009CA E998            	   708:                 rol.l   #4,d0           ; get upper nibble of upper byte
00:000009CC 10350000        	   709:                 move.b  (a5,d0.w),d0    ; digit lookup in table
00:000009D0 4E93            	   710:                 jsr     (a3)
00:000009D2 4240            	   711:                 clr.w   d0
00:000009D4 E998            	   712:                 rol.l   #4,d0           ; get lower nibble of upper byte
00:000009D6 10350000        	   713:                 move.b  (a5,d0.w),d0    ; digit lookup in table
00:000009DA 4E93            	   714:                 jsr     (a3)
00:000009DC 4240            	   715:                 clr.w   d0
00:000009DE 60D4            	   716:                 bra     _lsb
                            	   717: 
                            	   718: ; InChar - read one character from current input device
                            	   719: ; Arguments:    none
                            	   720: ; Returns:      character in low byte of D0
                            	   721: ; Blocks until a character is received.
00:000009E0 227900E00004    	   722: SYS_InChar:     move.l  INCH_VEC,a1
00:000009E6 4E91            	   723:                 jsr     (a1)
00:000009E8 4E73            	   724:                 rte
                            	   725: 
                            	   726: 
                            	   727: ; PromptStr - prompt for string from input device
                            	   728: ; Arguments:    A0.L - destination buffer
                            	   729: ;               D0.L - maximum length
                            	   730: ;               D1.W - delimiter character and flags
                            	   731: ;                       bit 9:    if set, do NOT interpret control characters
                            	   732: ;                       bit 8:    if set, do NOT echo received characters to the output device
                            	   733: ;                                 if clear, received characters are echoed to the output device
                            	   734: ;                       bits 7-0: delimiter character
                            	   735: ; Returns:      A0.L - unmodified (points to start of string)
                            	   736: ;               (A0) - null-terminated string
                            	   737: ;               D0.L - number of characters received (excluding null byte)
                            	   738: ; The string is null-terminated. The buffer should have enough space for maxlen+1 bytes.
                            	   739: ; Control characters supported:
                            	   740: ; ^C - return immediately with an empty string
                            	   741: ; ^H - backspace one character
                            	   742: ; ^? (DEL) - baskspace one character
                            	   743: ; ^M (CR) - translated to ^J (LF)
                            	   744: SYS_PromptStr:  pushm   a0/a2-a3/d2
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:000009EA 48E720B0        	     4M                 movem.l a0/a2-a3/d2,-(sp)
00:000009EE 2448            	   745:                 move.l  a0,a2           ; pointer within buffer
00:000009F0 47F00000        	   746:                 lea.l   (a0,d0),a3      ; pointer to end of buffer
00:000009F4 3401            	   747:                 move.w  d1,d2           ; delimiter char and flags
                            	   748: 
00:000009F6 227900E00004    	   749: .prompt:        move.l  INCH_VEC,a1     ; get character
00:000009FC 4E91            	   750:                 jsr     (a1)
00:000009FE B400            	   751: .tstchar:       cmp.b   d0,d2
00:00000A00 6732            	   752:                 beq     .founddelim     ; if it's the delimiter character, we're done
00:00000A02 08020009        	   753:                 btst.l  #PRbNOCTRLCHARS,d2      ; check for control chars?
00:00000A06 661C            	   754:                 bne     .noctrlchar
                            	   755:         ; check if it's a control character
00:00000A08 B03C0008        	   756:                 cmp.b   #$08,d0         ; backspace
00:00000A0C 6734            	   757:                 beq     .backspace
00:00000A0E B03C007F        	   758:                 cmp.b   #$7f,d0         ; delete
00:00000A12 672E            	   759:                 beq     .backspace
00:00000A14 B03C0003        	   760:                 cmp.b   #$03,d0         ; ctrl-c
00:00000A18 673E            	   761:                 beq     .abort
00:00000A1A B03C000D        	   762:                 cmp.b   #$0d,d0         ; CR -> LF
00:00000A1E 6604            	   763:                 bne     .noctrlchar
00:00000A20 700A            	   764:                 moveq   #$0a,d0
00:00000A22 60DA            	   765:                 bra     .tstchar
00:00000A24 B7CA            	   766: .noctrlchar:    cmp.l   a2,a3           ; is there room in the string?
00:00000A26 67CE            	   767:                 beq     .prompt         ; if not, ignore the character
                            	   768:         ; there is room in the string and the character is not a delimiter
00:00000A28 14C0            	   769:                 move.b  d0,(a2)+        ; store in buffer
                            	   770:         ; echo it?
00:00000A2A 08020008        	   771:                 btst.l  #PRbNOECHO,d2
00:00000A2E 66C6            	   772:                 bne     .prompt
                            	   773:                 sys     OutChar
00:00000A30 4E42            	     1M                 trap    #OutChar
00:00000A32 60C2            	   774:                 bra     .prompt
                            	   775: 
00:00000A34 14BC0000        	   776: .founddelim:    move.b  #0,(a2)         ; null-terminate the string
00:00000A38 200A            	   777:                 move.l  a2,d0           ; save the address of the null byte
                            	   778:                 popm    a0/a2-a3/d2     ; a0 now contains pointer to start of buffer
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000A3A 4CDF0D04        	     4M                 movem.l (sp)+,a0/a2-a3/d2
00:00000A3E 9088            	   779:                 sub.l   a0,d0           ; d0 contains length of string in buffer
00:00000A40 4E73            	   780:                 rte
                            	   781: 
00:00000A42 B5EF0004        	   782: .backspace:     cmp.l   4(sp),a2        ; can't backspace if we're at the start of the string
00:00000A46 67AE            	   783:                 beq     .prompt
00:00000A48 534A            	   784:                 subq    #1,a2
                            	   785:         ; if echo is enabled, print backspace/space/backspace
00:00000A4A 08020008        	   786:                 btst.l  #PRbNOECHO,d2
00:00000A4E 66A6            	   787:                 bne     .prompt
00:00000A50 41F80A64        	   788:                 lea.l   .backspacestr,a0
                            	   789:                 sys     OutStr
00:00000A54 4E43            	     1M                 trap    #OutStr
00:00000A56 609E            	   790:                 bra     .prompt
                            	   791: 
                            	   792: .abort:         popm    a0/a2-a3/d2
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000A58 4CDF0D04        	     4M                 movem.l (sp)+,a0/a2-a3/d2
00:00000A5C 10BC0000        	   793:                 move.b  #0,(a0)         ; return the empty string
00:00000A60 4200            	   794:                 clr.b   d0
00:00000A62 4E73            	   795:                 rte
                            	   796: 
00:00000A64 08              	   797: .backspacestr:  dc.b    $08,$20,$08,0
00:00000A65 20
00:00000A66 08
00:00000A67 00
                            	   798: 
                            	   799: 
                            	   800: ; ReadSector - read one sector from CF card
                            	   801: ; Arguments:    D0.L - sector number (LBA)
                            	   802: ;               D1.L - size of destination memory buffer (pass any value >= 512 to load entire sector)
                            	   803: ;               A0.L - address of destination buffer
                            	   804: ; Returns:      D0.B - error code, or 0 if successful
                            	   805: ;               D1.L - decremented by number of bytes read
                            	   806: ;               A0.L - advanced
                            	   807: ; note: A0 must be word-aligned
00:00000A68 2F01            	   808: SYS_ReadSector: move.l  d1,-(sp)
00:00000A6A 43F900900000    	   809:                 lea.l   CFCARD,a1
00:00000A70 E158            	   810:                 rol.w   #8,d0           ; byte-swap the block address
00:00000A72 4840            	   811:                 swap    d0
00:00000A74 E158            	   812:                 rol.w   #8,d0
00:00000A76 803C00E0        	   813:                 or.b    #$E0,d0         ; set LBA bits
00:00000A7A 01C90007        	   814:                 movep.l d0,CF_LBA0(a1)  ; write LBA to registers
00:00000A7E 137C00010005    	   815:                 move.b  #1,CF_COUNT(a1) ; read one sector
00:00000A84 7020            	   816:                 moveq   #CFCMD_RDSECTOR,d0
00:00000A86 61000180        	   817:                 bsr     _cfcard_sendcmd
00:00000A8A 6638            	   818:                 bne     .done
00:00000A8C 610001C2        	   819:                 bsr     _cfcard_waitfordata
00:00000A90 6632            	   820:                 bne     .done
                            	   821:         ; cap d1 at 512
00:00000A92 203C00000200    	   822:                 move.l  #SECTORSIZE,d0
00:00000A98 B280            	   823:                 cmp.l   d0,d1
00:00000A9A 6302            	   824:                 bls     .1
00:00000A9C 2200            	   825:                 move.l  d0,d1
                            	   826:         ; convert bytes to words
00:00000A9E 9397            	   827: .1:             sub.l   d1,(sp)         ; subtract actual number of bytes to read from buffer size on stack
00:00000AA0 E249            	   828:                 lsr.w   #1,d1           ; X flag will be set if there's a residual byte left
00:00000AA2 670C            	   829:                 beq     .2
00:00000AA4 6006            	   830:                 bra     .3
00:00000AA6 3011            	   831: .readloop:      move.w  CF_DATA(a1),d0
00:00000AA8 E058            	   832:                 ror.w   #8,d0           ; words need to be byte-swapped
00:00000AAA 30C0            	   833:                 move.w  d0,(a0)+
00:00000AAC 51C9FFF8        	   834: .3:             dbra    d1,.readloop
                            	   835:         ; handle the residual byte if X is set
00:00000AB0 E211            	   836: .2:             roxr.b  #1,d1           ; shift into N flag
00:00000AB2 6A04            	   837:                 bpl     .flush
00:00000AB4 3011            	   838:                 move.w  CF_DATA(a1),d0
00:00000AB6 10C0            	   839:                 move.b  d0,(a0)+
                            	   840:         ; consume the rest of the card's data buffer if there's still data left
00:00000AB8 4A51            	   841: .flush:         tst.w   CF_DATA(a1)
00:00000ABA 08290003000F    	   842:                 btst.b  #3,CF_STATUS(a1)
00:00000AC0 66F6            	   843:                 bne     .flush
00:00000AC2 7000            	   844:                 moveq   #0,d0           ; no error
00:00000AC4 221F            	   845: .done:          move.l  (sp)+,d1        ; bring remaining buffer capacity back to d1
00:00000AC6 4E73            	   846:                 rte
                            	   847: 
                            	   848: 
                            	   849: ; ListDirectory - traverse the root directory on the CF card
                            	   850: ; Arguments:    A0.L - pointer to buffer at least DIRBUFSIZE bytes
                            	   851: ;               D0.L - should be nonzero on first call; zero on subsequent calls
                            	   852: ; Returns:      A0.L - preserved
                            	   853: ;               A1.L - pointer to 32-byte directory entry within the buffer
                            	   854: ;               D0.W - if 0, there are still entries to iterate over
                            	   855: ;                      if < 0, iteration is complete
                            	   856: ;                      if > 0, an error occurred
                            	   857: ;               (A0) - advanced
                            	   858: ; note: A0 must be word-aligned
                            	   859: SYS_ListDirectory:
00:00000AC8 4A80            	   860:                 tst.l   d0
00:00000ACA 6706            	   861:                 beq     .1
                            	   862:         ; D0 nonzero? if so, initializer directory buffer
00:00000ACC 610002C0        	   863:                 bsr     fs_rdirlist
00:00000AD0 6604            	   864:                 bne     .error
                            	   865:         ; load first entry
00:00000AD2 610002D8        	   866: .1:             bsr     fs_dirnext
00:00000AD6 4E73            	   867: .error:         rte
                            	   868: 
                            	   869: 
                            	   870: ; FindFile - return the directory entry for the file with the given name
                            	   871: ; Arguments:    A0.L - pointer to null-terminated 8.3 filename
                            	   872: ;               A1.L - 32-byte buffer to copy the directory entry to
                            	   873: ; Returns:      D0.B - error code (0 on success, nonzero on error)
                            	   874: ;               A1.L - unmodified
                            	   875: SYS_FindFile:
00:00000AD8 61000344        	   876:                 bsr     fs_findfile
00:00000ADC 4E73            	   877:                 rte
                            	   878: 
                            	   879: 
                            	   880: ; ReadFile - read file from the root directory of the CF card into memory
                            	   881: ; Arguments:    A0.L - pointer to null-terminated 8.3 filename
                            	   882: ;               A1.L - memory address where the file should be loaded into
                            	   883: ;               D0.L - maximum file size in bytes
                            	   884: ; Returns:      D0.B - error code (0 on success, nonzero on error)
                            	   885: ;               D1.L - actual file size in bytes
00:00000ADE 61000436        	   886: SYS_ReadFile:   bsr     fs_loadfile
00:00000AE2 4E73            	   887:                 rte
                            	   888: 
                            	   889: 
                            	   890: ; GetDateTime - read the current date and time from the real-time clock
                            	   891: ; Arguments:    none
                            	   892: ; Returns:      D0.L - date
                            	   893: ;                       bits 31-16: year (four BCD digits)
                            	   894: ;                       bits 15-8:  month (two BCD digits)
                            	   895: ;                       bits 7-0:   date (two BCD digits)
                            	   896: ;               D1.L - weekday and time
                            	   897: ;                       bits 26-24: weekday (one BCD digit)
                            	   898: ;                       bits 23-16: hour (two BCD digits)
                            	   899: ;                       bits 15-8:  minute (two BCD digits)
                            	   900: ;                       bits 7-0:   second (two BCD digits)
                            	   901: ; On error, D0 and D1 both equal 0.
                            	   902: ; Since 00000000 is never a valid date, checking for date valididity only requires
                            	   903: ; testing d0.
                            	   904: SYS_GetDateTime:
00:00000AE4 4E56FFF8        	   905:                 link    a6,#-8          ; push a6 and allocate two longwords
00:00000AE8 61000626        	   906:                 bsr     spi_startxfer   ; assert chip select
00:00000AEC 7000            	   907:                 moveq   #0,d0
00:00000AEE 6100063C        	   908:                 bsr     spi_shiftbyte   ; send register number $00
00:00000AF2 61000638        	   909:                 bsr     spi_shiftbyte   ; read in byte 0 (seconds)
00:00000AF6 1D00            	   910:                 move.b  d0,-(a6)
00:00000AF8 6B62            	   911:                 bmi     .rtc_error      ; bit 7 should be 0 -- if it is, RTC not detected
00:00000AFA 61000630        	   912:                 bsr     spi_shiftbyte   ; read in byte 1 (minutes)
00:00000AFE 1D00            	   913:                 move.b  d0,-(a6)
00:00000B00 6100062A        	   914:                 bsr     spi_shiftbyte   ; read in byte 2 (hours)
00:00000B04 1D00            	   915:                 move.b  d0,-(a6)
00:00000B06 61000624        	   916:                 bsr     spi_shiftbyte   ; read in byte 3 (weekday)
00:00000B0A 1D00            	   917:                 move.b  d0,-(a6)
00:00000B0C 6100061E        	   918:                 bsr     spi_shiftbyte   ; read in byte 4 (date)
00:00000B10 1D00            	   919:                 move.b  d0,-(a6)
00:00000B12 61000618        	   920:                 bsr     spi_shiftbyte   ; read in byte 5 (month/century)
00:00000B16 4A00            	   921:                 tst.b   d0              ; check century bit
00:00000B18 6B0E            	   922:                 bmi     .twenty_second_century
                            	   923:         ; 21st century (century=0)
00:00000B1A 1D00            	   924:                 move.b  d0,-(a6)        ; store byte 5
00:00000B1C 6100060E        	   925:                 bsr     spi_shiftbyte   ; read in byte 6 (year)
00:00000B20 1D00            	   926:                 move.b  d0,-(a6)
00:00000B22 1D3C0020        	   927:                 move.b  #$20,-(a6)      ; upper 2 year digits
00:00000B26 6010            	   928:                 bra     .1
                            	   929: .twenty_second_century:
00:00000B28 08800007        	   930:                 bclr.l  #7,d0           ; clear century bit
00:00000B2C 1D00            	   931:                 move.b  d0,-(a6)        ; store byte 5
00:00000B2E 610005FC        	   932:                 bsr     spi_shiftbyte   ; read in byte 6 (year)
00:00000B32 1D00            	   933:                 move.b  d0,-(a6)
00:00000B34 1D3C0021        	   934:                 move.b  #$21,-(a6)      ; upper 2 year digits
00:00000B38 610005E6        	   935: .1:             bsr     spi_endxfer     ; deassert chip select
                            	   936: 
00:00000B3C 610005D2        	   937:                 bsr     spi_startxfer   ; assert chip select
00:00000B40 700F            	   938:                 moveq   #$0F,d0         ; register $0F: control/status
00:00000B42 610005E8        	   939:                 bsr     spi_shiftbyte   ; send register number $0F
00:00000B46 610005E4        	   940:                 bsr     spi_shiftbyte   ; read data byte
00:00000B4A 4A00            	   941:                 tst.b   d0
00:00000B4C 6A04            	   942:                 bpl     .nopwrloss
00:00000B4E 08D60007        	   943:                 bset.b  #7,(a6)         ; set power-loss bit
00:00000B52 610005CC        	   944: .nopwrloss:     bsr     spi_endxfer
                            	   945:                 popm    d0-d1/a6        ; pop date/time into return registers, restore a6
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000B56 4CDF4003        	     4M                 movem.l (sp)+,d0-d1/a6
00:00000B5A 4E73            	   946:                 rte
00:00000B5C 610005C2        	   947: .rtc_error:     bsr     spi_endxfer     ; deassert chip select
00:00000B60 7000            	   948:                 moveq   #0,d0           ; return 0
00:00000B62 7200            	   949:                 moveq   #0,d1
00:00000B64 504F            	   950:                 addq    #8,sp
                            	   951:                 pop     a6
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:00000B66 2C5F            	     4M                 move.l  (sp)+,a6
00:00000B68 4E73            	   952:                 rte
                            	   953: 
                            	   954: 
                            	   955: ; SetDateTime - set the real-time clock's current date and time
                            	   956: ; Arguments:    D0.L - date
                            	   957: ;                       bits 31-16: year (four BCD digits)
                            	   958: ;                       bits 15-8:  month (two BCD digits)
                            	   959: ;                       bits 7-0:   date (two BCD digits)
                            	   960: ;               D1.L - weekday and time
                            	   961: ;                       bits 26-24: weekday (one BCD digit)
                            	   962: ;                       bits 23-16: hour (two BCD digits)
                            	   963: ;                       bits 15-8:  minute (two BCD digits)
                            	   964: ;                       bits 7-0:   second (two BCD digit)
                            	   965: ; No validation of the date (bounds-checking fields, ensuring valid BCD) is performed.
                            	   966: SYS_SetDateTime:
00:00000B6A 4E560000        	   967:                 link    a6,#0
00:00000B6E 48E7C000        	   968:                 movem.l d0-d1,-(sp)
00:00000B72 6100059C        	   969:                 bsr     spi_startxfer   ; assert chip select
00:00000B76 7040D040        	   970:                 move.l  #$80,d0
00:00000B7A 610005B0        	   971:                 bsr     spi_shiftbyte   ; send register number $89
00:00000B7E 1026            	   972:                 move.b  -(a6),d0
00:00000B80 610005AA        	   973:                 bsr     spi_shiftbyte   ; set byte 0 (seconds)
00:00000B84 1026            	   974:                 move.b  -(a6),d0
00:00000B86 610005A4        	   975:                 bsr     spi_shiftbyte   ; set byte 1 (minutes)
00:00000B8A 1026            	   976:                 move.b  -(a6),d0
00:00000B8C 6100059E        	   977:                 bsr     spi_shiftbyte   ; set byte 2 (hours)
00:00000B90 1026            	   978:                 move.b  -(a6),d0
00:00000B92 61000598        	   979:                 bsr     spi_shiftbyte   ; set byte 3 (weekday)
00:00000B96 1026            	   980:                 move.b  -(a6),d0
00:00000B98 61000592        	   981:                 bsr     spi_shiftbyte   ; set byte 4 (date)
00:00000B9C 1026            	   982:                 move.b  -(a6),d0        ; get month
00:00000B9E 082E0000FFFE    	   983:                 btst.b  #0,-2(a6)       ; check lsb of century
00:00000BA4 6704            	   984:                 beq     .1
00:00000BA6 08C00007        	   985:                 bset.l  #7,d0           ; if it's 1, set century bit
00:00000BAA 61000580        	   986: .1:             bsr     spi_shiftbyte   ; set byte 5 (month/century)
00:00000BAE 1026            	   987:                 move.b  -(a6),d0
00:00000BB0 6100057A        	   988:                 bsr     spi_shiftbyte   ; set byte 6 (year)
00:00000BB4 6100056A        	   989:                 bsr     spi_endxfer     ; deassert chip select
                            	   990: 
00:00000BB8 61000556        	   991:                 bsr     spi_startxfer   ; assert chip select
00:00000BBC 203C0000008F    	   992:                 move.l  #$8F,d0         ; send register number $89
00:00000BC2 61000568        	   993:                 bsr     spi_shiftbyte
00:00000BC6 7040            	   994:                 moveq   #$40,d0         ; clear OSF flag
00:00000BC8 61000562        	   995:                 bsr     spi_shiftbyte   ; send data byte
00:00000BCC 61000552        	   996:                 bsr     spi_endxfer     ; deassert chip select
                            	   997: 
00:00000BD0 504F            	   998:                 addq    #8,sp
                            	   999:                 pop     a6
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:00000BD2 2C5F            	     4M                 move.l  (sp)+,a6
00:00000BD4 4E73            	  1000:                 rte
                            	  1001: 
                            	  1002: 
                            	  1003: ; GetSysInfo - get pointer to system information structure
                            	  1004: ; Arguments:    none
                            	  1005: ; Returns:      A0.L - pointer to system information structure:
                            	  1006: ;                0(A0).L - CPU clock speed in Hz
                            	  1007: ;                4(A0).L - RAM size in bytes
                            	  1008: ;                8(A0).L - ROM size in bytes
                            	  1009: ;               12(A0).L - ROM date
                            	  1010: ;               16(A0).W - ROM major revision
                            	  1011: ;               18(A0).W - ROM minor revision
00:00000BD6 41F90000FFEC    	  1012: SYS_GetSysInfo: lea.l   sysinfo,a0
00:00000BDC 4E73            	  1013:                 rte
                            	  1014: 
                            	  1015: 
                            	  1016: ;-------------------------------------------------------------------------------
                            	  1017: ; CompactFlash card
                            	  1018: ;-------------------------------------------------------------------------------
00:00000BDE 70FF            	  1019: cfcard_init:    moveq   #-1,d0
00:00000BE0 0C3900500090000F	  1020: .1:             cmp.b   #$50,CFCARD+CF_STATUS
00:00000BE8 670E            	  1021:                 beq     .found
00:00000BEA 57C8FFF4        	  1022:                 dbeq    d0,.1
00:00000BEE 08B9000700A0000E	  1023: .notfound:      bclr.b  #7,UART+SCR
00:00000BF6 6008            	  1024:                 bra     .2
00:00000BF8 08F9000700A0000E	  1025: .found:         bset.b  #7,UART+SCR
00:00000C00 4E75            	  1026: .2:             rts
                            	  1027: 
                            	  1028: 
                            	  1029: ; Send a commnd to the CF card.
                            	  1030: ; Arguments:    command byte in D0
                            	  1031: ;               CF card base address in A1
                            	  1032: ; Returns:      error code in low byte of D0: zero if command succeeded
                            	  1033: cfcard_sendcmd:
00:00000C02 43F900900000    	  1034:                 lea.l   CFCARD,a1
                            	  1035: _cfcard_sendcmd:
00:00000C08 1340000F        	  1036:                 move.b  d0,CF_COMMAND(a1)
00:00000C0C 70FF            	  1037:                 moveq   #-1,d0                  ; initialize timeout counter
00:00000C0E 08290007000F    	  1038: .busy:          btst.b  #7,CF_STATUS(a1)        ; wait until card is not busy (bit 7 clear)
00:00000C14 6708            	  1039:                 beq     .notbusy
00:00000C16 51C8FFF6        	  1040:                 dbra    d0,.busy
00:00000C1A 7020            	  1041: .timeout:       moveq   #FSERR_TIMEOUT,d0
00:00000C1C 4E75            	  1042:                 rts
                            	  1043: 
00:00000C1E 70FF            	  1044: .notbusy:       moveq   #-1,d0                  ; initialize timeout counter
00:00000C20 08290004000F    	  1045: .notready:      btst.b  #4,CF_STATUS(a1)        ; wait until card is ready (bit 4 set)
00:00000C26 660E            	  1046:                 bne     .ready
00:00000C28 51C8FFF6        	  1047:                 dbra    d0,.notready
00:00000C2C 08290000000F    	  1048: .rdytimeout:    btst.b  #0,CF_STATUS(a1)        ; an error code set?
00:00000C32 660E            	  1049:                 bne     .err
00:00000C34 60E4            	  1050:                 bra     .timeout
                            	  1051: 
00:00000C36 08290000000F    	  1052: .ready:         btst.b  #0,CF_STATUS(a1)        ; check error register
00:00000C3C 6604            	  1053:                 bne     .err
00:00000C3E 7000            	  1054:                 moveq   #0,d0                   ; no error? return 0 in D0
00:00000C40 4E75            	  1055:                 rts
00:00000C42 7000            	  1056: .err:           moveq   #0,d0
00:00000C44 10290003        	  1057:                 move.b  CF_ERROR(a1),d0         ; return error status in D0
00:00000C48 4E75            	  1058:                 rts
                            	  1059: 
                            	  1060: 
                            	  1061: ; Wait until the card is ready for a data transfer.
                            	  1062: ; Arguments:    CF card base address in A1
                            	  1063: ; Returns:      error code in low byte of D0: zero if command succeeded
                            	  1064: cfcard_waitfordata:
00:00000C4A 43F900900000    	  1065:                 lea.l   CFCARD,a1
                            	  1066: _cfcard_waitfordata:
00:00000C50 70FF            	  1067:                 moveq   #-1,d0                  ; initialize timeout counter
00:00000C52 08290003000F    	  1068: .nodata:        btst.b  #3,CF_STATUS(a1)        ; wait until data is present (bit 3 set)
00:00000C58 6610            	  1069:                 bne     .gotdata
00:00000C5A 51C8FFF6        	  1070:                 dbra    d0,.nodata
00:00000C5E 08290000000F    	  1071: .datatimeout:   btst.b  #0,CF_STATUS(a1)        ; check error register
00:00000C64 6610            	  1072:                 bne     .err
00:00000C66 7020            	  1073:                 moveq   #FSERR_TIMEOUT,d0
00:00000C68 4E75            	  1074:                 rts
00:00000C6A 08290000000F    	  1075: .gotdata:       btst.b  #0,CF_STATUS(a1)        ; check error register
00:00000C70 6604            	  1076:                 bne     .err
00:00000C72 7000            	  1077:                 moveq   #0,d0                   ; no error? return 0 in D0
00:00000C74 4E75            	  1078:                 rts
00:00000C76 7000            	  1079: .err:           moveq   #0,d0
00:00000C78 10290003        	  1080:                 move.b  CF_ERROR(a1),d0         ; return error status in D0
00:00000C7C 4E75            	  1081:                 rts
                            	  1082: 
                            	  1083: 
                            	  1084: 
                            	  1085: ;-------------------------------------------------------------------------------
                            	  1086: ; FAT16 filesystem
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: fs_mount:
                            	  1089:         ; clear filesystem info
00:00000C7E 303C0014        	  1090:                 move.w  #(FSVARLEN/2)-1,d0
00:00000C82 41F900E00010    	  1091:                 lea.l   FSVARSTART,a0
00:00000C88 4258            	  1092: .1:             clr.w   (a0)+
00:00000C8A 51C8FFFC        	  1093:                 dbra    d0,.1
                            	  1094:         ; read the master boot record
00:00000C8E 4E56FE00        	  1095:                 link    a6,#-SECTORSIZE ; allocate a buffer on the stack for the sector
00:00000C92 7000            	  1096:                 moveq   #0,d0           ; read sector 0
00:00000C94 204F            	  1097:                 move.l  sp,a0
00:00000C96 72FF            	  1098:                 moveq   #-1,d1          ; read entire sector
                            	  1099:                 sys     ReadSector
00:00000C98 4E47            	     1M                 trap    #ReadSector
00:00000C9A 4A40            	  1100:                 tst     d0
00:00000C9C 660000D6        	  1101:                 bne     .error
                            	  1102:         ; ignore the first 446 bytes and get to the first partition table entry
00:00000CA0 41EF01BE        	  1103:                 lea.l   $1BE(sp),a0
                            	  1104:         ; check partition type to make sure it's FAT16
00:00000CA4 10280004        	  1105:                 move.b  4(a0),d0        ; get partition type
00:00000CA8 B03C0004        	  1106:                 cmp.b   #$04,d0         ; FAT16 <32MB
00:00000CAC 6712            	  1107:                 beq     .isfat16
00:00000CAE B03C0006        	  1108:                 cmp.b   #$06,d0         ; FAT16 >=32MB
00:00000CB2 670C            	  1109:                 beq     .isfat16
00:00000CB4 B03C000B        	  1110:                 cmp.b   #$0B,d0         ; FAT16 or FAT32
00:00000CB8 6706            	  1111:                 beq     .isfat16
                            	  1112: ; partition is not FAT16
00:00000CBA 7021            	  1113: .notfat16:      moveq   #FSERR_WRONGTYPE,d0
00:00000CBC 600000B6        	  1114:                 bra     .error
                            	  1115: .isfat16:
                            	  1116:         ; Partition size and LBA of first sector (BIOS Parameter Block)
                            	  1117:         ; Both need to be byteswapped
00:00000CC0 41E80010        	  1118:                 lea.l   16(a0),a0
00:00000CC4 43F900E00010    	  1119:                 lea.l   PARTSIZE,a1
00:00000CCA 12E0            	  1120:                 move.b  -(a0),(a1)+
00:00000CCC 12E0            	  1121:                 move.b  -(a0),(a1)+
00:00000CCE 12E0            	  1122:                 move.b  -(a0),(a1)+
00:00000CD0 12E0            	  1123:                 move.b  -(a0),(a1)+
00:00000CD2 12E0            	  1124:                 move.b  -(a0),(a1)+
00:00000CD4 12E0            	  1125:                 move.b  -(a0),(a1)+
00:00000CD6 12E0            	  1126:                 move.b  -(a0),(a1)+
00:00000CD8 12E0            	  1127:                 move.b  -(a0),(a1)+
                            	  1128:         ; now load the BIOS Parameter Block from the first sector
00:00000CDA 203900E00014    	  1129:                 move.l  BPBSECTOR,d0
00:00000CE0 204F            	  1130:                 move.l  sp,a0
00:00000CE2 72FF            	  1131:                 moveq   #-1,d1          ; read entire sector
                            	  1132:                 sys     ReadSector
00:00000CE4 4E47            	     1M                 trap    #ReadSector
00:00000CE6 4A40            	  1133:                 tst     d0
00:00000CE8 6600008A        	  1134:                 bne     .error
                            	  1135:         ; read backwards, since the values need to be byte-swapped
00:00000CEC 41EF0018        	  1136:                 lea.l   24(sp),a0
00:00000CF0 43F900E00018    	  1137:                 lea.l   FATSIZE,a1
00:00000CF6 12E0            	  1138:                 move.b  -(a0),(a1)+     ; Logical sectors per FAT
00:00000CF8 12E0            	  1139:                 move.b  -(a0),(a1)+
00:00000CFA 5748            	  1140:                 subq    #3,a0
00:00000CFC 12E0            	  1141:                 move.b  -(a0),(a1)+     ; Max root directory entries
00:00000CFE 12E0            	  1142:                 move.b  -(a0),(a1)+
00:00000D00 4219            	  1143:                 clr.b   (a1)+           ; Number of FATs
00:00000D02 12E0            	  1144:                 move.b  -(a0),(a1)+
00:00000D04 12E0            	  1145:                 move.b  -(a0),(a1)+     ; Number of reserved logical sectors
00:00000D06 12E0            	  1146:                 move.b  -(a0),(a1)+
00:00000D08 4219            	  1147:                 clr.b   (a1)+           ; Sectors per cluster
00:00000D0A 12E0            	  1148:                 move.b  -(a0),(a1)+
                            	  1149:         ; don't support drives when bytes per sector is not 512
00:00000D0C 1020            	  1150:                 move.b  -(a0),d0
00:00000D0E E148            	  1151:                 lsl.w   #8,d0
00:00000D10 1020            	  1152:                 move.b  -(a0),d0
00:00000D12 B07C0200        	  1153:                 cmp.w   #SECTORSIZE,d0
00:00000D16 665A            	  1154:                 bne     .not512bps
                            	  1155:         ; if max root dir entries is 0, this is a FAT32 partition that we can't read
00:00000D18 4A7900E0001A    	  1156:                 tst.w   MAXRDIRENTS
00:00000D1E 679A            	  1157:                 beq     .notfat16
                            	  1158:         ; copy volume name
00:00000D20 41E80020        	  1159:                 lea.l   32(a0),a0
00:00000D24 43F900E0002E    	  1160:                 lea.l   VOLNAME,a1
00:00000D2A 700A            	  1161:                 moveq   #10,d0          ; 11 characters in volume name
00:00000D2C 12D8            	  1162: .namecopy:      move.b  (a0)+,(a1)+
00:00000D2E 51C8FFFC        	  1163:                 dbra    d0,.namecopy
                            	  1164:         ; compute FAT sector = BPBSECTOR + RSVDSECTORS
00:00000D32 7000            	  1165:                 moveq   #0,d0
00:00000D34 303900E0001E    	  1166:                 move.w  RSVDSECTORS,d0
00:00000D3A D0B900E00014    	  1167:                 add.l   BPBSECTOR,d0
00:00000D40 23C000E00026    	  1168:                 move.l  d0,FATSECTOR
                            	  1169:         ; compute root directory sector = FATSECTOR + FATSIZE*FATCOPIES
00:00000D46 323900E0001C    	  1170:                 move.w  FATCOPIES,d1
00:00000D4C C2F900E00018    	  1171:                 mulu.w  FATSIZE,d1
00:00000D52 D081            	  1172:                 add.l   d1,d0
00:00000D54 23C000E00022    	  1173:                 move.l  d0,RDIRSECTOR
                            	  1174:         ; calculate size of root directory entry in sectors
                            	  1175:         ; (directory entries are 32 bytes and a sector is 512 bytes)
                            	  1176:         ; = (MAXRDIRENTS * 32) / 512 = MAXRDIRENTS / 16 = MAXRDIRENTS >> 4
00:00000D5A 323900E0001A    	  1177:                 move.w  MAXRDIRENTS,d1
00:00000D60 E849            	  1178:                 lsr.w   #4,d1
00:00000D62 48C1            	  1179:                 ext.l   d1
                            	  1180:         ; calculate first data sector = RDIRSECTOR + (MAXDIRENTS >> 4)
00:00000D64 D081            	  1181:                 add.l   d1,d0
00:00000D66 23C000E0002A    	  1182:                 move.l  d0,DATASTART
                            	  1183:                 
00:00000D6C 7000            	  1184:                 moveq   #0,d0
00:00000D6E 4E5E            	  1185: .2:             unlk    a6
00:00000D70 4E75            	  1186:                 rts
00:00000D72 7022            	  1187: .not512bps:     moveq   #FSERR_BPS,d0
00:00000D74 42B900E00010    	  1188: .error:         clr.l   PARTSIZE        ; clear PARTSIZE to indicate drive is not mounted
00:00000D7A 4A40            	  1189:                 tst     d0
00:00000D7C 60F0            	  1190:                 bra     .2
                            	  1191: 
                            	  1192: 
                            	  1193: ; Return a string describing an error code.
                            	  1194: ; Arguments:    D0 - error code
                            	  1195: ; Returns:      A0 - pointer to null-terminated string
                            	  1196: ;               D0 - unmodified
00:00000D7E 7200            	  1197: fs_errorstr:    moveq   #0,d1
00:00000D80 1200            	  1198:                 move.b  d0,d1
00:00000D82 E549            	  1199:                 lsl.w   #2,d1           ; multiply by 4 to get table offset
00:00000D84 41F81828        	  1200:                 lea.l   fserrtable,a0
00:00000D88 20701000        	  1201:                 move.l  (a0,d1.w),a0    ; set Z flag if null ptr
00:00000D8C 4E75            	  1202:                 rts
                            	  1203: 
                            	  1204: 
                            	  1205: ; Begin traversal of the root directory.
                            	  1206: ; Arguments:    A0.L - pointer to uninitialized buffer at least DIRBUFSIZE bytes
                            	  1207: ; Returns:      D0.B - error code, or 0 if successful
                            	  1208: ;               (A0) - initialized directory buffer
                            	  1209: ; note: A0 must be word-aligned
00:00000D8E 4AB900E00010    	  1210: fs_rdirlist:    tst.l   PARTSIZE
00:00000D94 6712            	  1211:                 beq     .notmounted
00:00000D96 30B900E0001A    	  1212:                 move.w  MAXRDIRENTS,(a0)        ; initialize entry counter
00:00000D9C 217900E000220004	  1213:                 move.l  RDIRSECTOR,4(a0)        ; initialize sector number
00:00000DA4 7000            	  1214:                 moveq   #0,d0
00:00000DA6 4E75            	  1215:                 rts
00:00000DA8 7023            	  1216: .notmounted:    moveq   #FSERR_NMOUNTED,d0
00:00000DAA 4E75            	  1217:                 rts
                            	  1218: 
                            	  1219: 
                            	  1220: ; Return the next entry in the directory being traversed.
                            	  1221: ; Arguments:    A0.L - pointer to directory buffer
                            	  1222: ; Returns:      A1.L - pointer to 32-byte directory entry within the buffer
                            	  1223: ;               D0.W - if 0, there are still entries to iterate over
                            	  1224: ;                      if < 0, iteration is complete
                            	  1225: ;                      if > 0, an error occurred
                            	  1226: ;               (A0) - advanced
                            	  1227: ; note: A0 must be word-aligned
00:00000DAC 4A50            	  1228: fs_dirnext:     tst.w   (a0)            ; done with iteration?
00:00000DAE 676A            	  1229:                 beq     .iterdone
                            	  1230:         ; Each sector (512 bytes) holds 16 directory entries.
                            	  1231:         ; Need to load a new sector when lower 4 bits of count are 0.
00:00000DB0 700F            	  1232:                 moveq   #$0F,d0
00:00000DB2 C050            	  1233:                 and.w   (a0),d0
00:00000DB4 6616            	  1234:                 bne     .noload
                            	  1235:         ; Load the sector.
                            	  1236:                 push    a0
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to push--use pushm if you want to push multiple registers
                            	     3M         endif
00:00000DB6 2F08            	     4M                 move.l  a0,-(sp)
00:00000DB8 20280004        	  1237:                 move.l  4(a0),d0        ; sector number to d0
00:00000DBC 5088            	  1238:                 lea.l   8(a0),a0        ; buffer address in a0
00:00000DBE 72FF            	  1239:                 moveq   #-1,d1          ; read entire sector
                            	  1240:                 sys     ReadSector
00:00000DC0 4E47            	     1M                 trap    #ReadSector
                            	  1241:                 pop     a0
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:00000DC2 205F            	     4M                 move.l  (sp)+,a0
00:00000DC4 4A00            	  1242:                 tst.b   d0              ; check error code
00:00000DC6 6654            	  1243:                 bne     .done
                            	  1244:         ; Advance sector number.
00:00000DC8 52A80004        	  1245:                 addq.l  #1,4(a0)
                            	  1246: .noload:
                            	  1247:         ; Negate lower 4 bits of count to get entry number within sector.
00:00000DCC 4400            	  1248:                 neg.b   d0
00:00000DCE C03C000F        	  1249:                 and.b   #$0F,d0
                            	  1250:         ; Multiply by 32 to get offset within sector.
00:00000DD2 EB48            	  1251:                 lsl.w   #5,d0
                            	  1252:         ; Load effective address of directory entry into A1
00:00000DD4 43F00008        	  1253:                 lea.l   8(a0,d0.w),a1
00:00000DD8 5350            	  1254:                 subq.w  #1,(a0)         ; decrement entry count
00:00000DDA 673E            	  1255:                 beq     .iterdone       ; last entry? return -1
                            	  1256:         ; If the first character of the filename is $00 or $E5, skip this entry
00:00000DDC 4A11            	  1257:                 tst.b   FNAME(a1)
00:00000DDE 67CC            	  1258:                 beq     fs_dirnext
00:00000DE0 0C1100E5        	  1259:                 cmp.b   #$E5,FNAME(a1)
00:00000DE4 67C6            	  1260:                 beq     fs_dirnext
                            	  1261:         ; If the attribute byte is $0F, it's a long filename entry, skip it
00:00000DE6 0C29000F000B    	  1262:                 cmp.b   #$0F,FATTRS(a1)
00:00000DEC 67BE            	  1263:                 beq     fs_dirnext
                            	  1264:         ; If it's a volume label or hidden file, skip it
00:00000DEE 08290001000B    	  1265:                 btst.b  #1,FATTRS(a1)
00:00000DF4 66B6            	  1266:                 bne     fs_dirnext
00:00000DF6 08290003000B    	  1267:                 btst.b  #3,FATTRS(a1)
00:00000DFC 66AE            	  1268:                 bne     fs_dirnext
                            	  1269:         ; It's a valid entry. Byteswap the cluster number and file size.
00:00000DFE 3029001A        	  1270:                 move.w  FCLUSTER(a1),d0      ; cluster number (2 bytes)
00:00000E02 E058            	  1271:                 ror.w   #8,d0
00:00000E04 3340001A        	  1272:                 move.w  d0,FCLUSTER(a1)
00:00000E08 2029001C        	  1273:                 move.l  $1c(a1),d0      ; file size (4 bytes)
00:00000E0C E058            	  1274:                 ror.w   #8,d0
00:00000E0E 4840            	  1275:                 swap    d0
00:00000E10 E058            	  1276:                 ror.w   #8,d0
00:00000E12 2340001C        	  1277:                 move.l  d0,$1c(a1)
00:00000E16 7000            	  1278:                 moveq   #0,d0           ; return 0 to indicate there's more
00:00000E18 4E75            	  1279:                 rts
00:00000E1A 70FF            	  1280: .iterdone:      moveq   #-1,d0
00:00000E1C 4E75            	  1281: .done:          rts
                            	  1282: 
                            	  1283: 
                            	  1284: ; Return the directory entry for the file with the given name.
                            	  1285: ; Arguments:    A0.L - pointer to null-terminated 8.3 filename
                            	  1286: ;               A1.L - 32-byte buffer to copy the directory entry to
                            	  1287: ; Returns:      D0.B - error code (0 on success, nonzero on error)
                            	  1288: ;               A1.L - unmodified
                            	  1289: ; All 11 bytes of the filename must match byte-for-byte.
                            	  1290: ; At least DIRBUFSIZE bytes of stack space are required for the temporary buffer.
                            	  1291: fs_findfile:    pushm   a2-a3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000E1E 48E70030        	     4M                 movem.l a2-a3,-(sp)
00:00000E22 2649            	  1292:                 move.l  a1,a3
00:00000E24 4E56FDEC        	  1293:                 link    a6,#-(DIRBUFSIZE+12)    ; 12 extra bytes for filename conversion (only need 11 but sp must stay
                            	  1294:         ; convert a0 to 11-byte encoded filename
00:00000E28 43EF0208        	  1295:                 lea.l   DIRBUFSIZE(sp),a1
00:00000E2C 61000138        	  1296:                 bsr     fname_encode
00:00000E30 6636            	  1297:                 bne     .ret
00:00000E32 2449            	  1298:                 move.l  a1,a2                   ; a2 points to 11-byte encoded filename
00:00000E34 204F            	  1299:                 move.l  sp,a0
                            	  1300:         ; initiate listing
00:00000E36 6100FF56        	  1301:                 bsr     fs_rdirlist
00:00000E3A 662C            	  1302:                 bne     .ret
                            	  1303:         ; iterate over directory entries until we find the file
00:00000E3C 204F            	  1304: .diriter:       move.l  sp,a0           ; directory buffer is at top of stack
00:00000E3E 6100FF6C        	  1305:                 bsr     fs_dirnext
00:00000E42 6B22            	  1306:                 bmi     .notfound       ; bail if we hit the end of the directory
00:00000E44 6622            	  1307:                 bne     .ret            ; bail if there's an error
                            	  1308:         ; a1 points to the directory entry. now compare filenames
                            	  1309:         ; all 11 bytes of name must be byte-for-byte equal
00:00000E46 204A            	  1310:                 move.l  a2,a0
00:00000E48 700A            	  1311:                 moveq   #FNAMELEN-1,d0
00:00000E4A B308            	  1312: .namecmp:       cmpm.b  (a0)+,(a1)+
00:00000E4C 66EE            	  1313:                 bne     .diriter        ; skip if names don't match
00:00000E4E 51C8FFFA        	  1314:                 dbra    d0,.namecmp
                            	  1315:         ; names match! copy the directory entry into the caller's buffer
00:00000E52 43E9FFF5        	  1316:                 lea.l   -FNAMELEN(a1),a1        ; back up to start of directory entry
00:00000E56 701F            	  1317:                 moveq   #DIRENTLEN-1,d0
00:00000E58 16D9            	  1318: .direntcmp:     move.b  (a1)+,(a3)+
00:00000E5A 51C8FFFC        	  1319:                 dbra    d0,.direntcmp
00:00000E5E 43EBFFE0        	  1320:                 lea.l   -DIRENTLEN(a3),a1       ; restore a1
00:00000E62 7000            	  1321:                 moveq   #0,d0
00:00000E64 6002            	  1322:                 bra     .ret
00:00000E66 7024            	  1323: .notfound:      moveq   #FSERR_NOTFOUND,d0
00:00000E68 4E5E            	  1324: .ret:           unlk    a6
                            	  1325:                 popm    a2-a3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000E6A 245F265F        	     4M                 movem.l (sp)+,a2-a3
00:00000E6E 4E75            	  1326:                 rts
                            	  1327: 
                            	  1328: 
                            	  1329: ; Load one cluster from CF card.
                            	  1330: ; Arguments:    D0.W - cluster number
                            	  1331: ;               D1.L - size of destination memory buffer
                            	  1332: ;               A0.L - destination memory buffer
                            	  1333: ; Returns:      A0.L - points one byte past the last byte written
                            	  1334: ;               D0.B - error code (0 on success, nonzero on error)
                            	  1335: ;               D1.W - bytes left in destination buffer
                            	  1336: ; note: A0 must be word-aligned
                            	  1337: fs_loadcluster: pushm   d2-d3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000E70 48E73000        	     4M                 movem.l d2-d3,-(sp)
                            	  1338:         ; check cluster number
00:00000E74 B07CFFF7        	  1339:                 cmp.w   #$FFF7,d0       ; indicates that cluster contains a bad sector
00:00000E78 6736            	  1340:                 beq     .badsector
00:00000E7A B07CFFF0        	  1341:                 cmp.w   #$FFF0,d0       ; $FFF0-$FFFF are invalid
00:00000E7E 6434            	  1342:                 bcc     .invclstr
00:00000E80 5540            	  1343:                 subq    #2,d0           ; $0001 and $0002 are invalid
00:00000E82 6B30            	  1344:                 bmi     .invclstr
                            	  1345:         ; convert cluster number to sector number
00:00000E84 343900E00020    	  1346:                 move.w  CLUSTERSIZE,d2
00:00000E8A C0C2            	  1347:                 mulu    d2,d0           ; multiply by number of sectors per cluster
00:00000E8C D0B900E0002A    	  1348:                 add.l   DATASTART,d0    ; add to first sector of data region
                            	  1349:         ; initialize counter with number of sectors per cluster
00:00000E92 2600            	  1350:                 move.l  d0,d3           ; save cluster number
00:00000E94 5342            	  1351:                 subq    #1,d2           ; subtract 1 for dbra
                            	  1352:         ; read sector
                            	  1353: .readloop:      sys     ReadSector
00:00000E96 4E47            	     1M                 trap    #ReadSector
00:00000E98 4A00            	  1354:                 tst.b   d0
00:00000E9A 660E            	  1355:                 bne     .error
                            	  1356:         ; stop if the buffer is full
00:00000E9C 4A81            	  1357:                 tst.l   d1
00:00000E9E 6708            	  1358:                 beq     .bufferfull
                            	  1359:         ; otherwise, read next sector in cluster
00:00000EA0 5283            	  1360:                 addq.l  #1,d3
00:00000EA2 2003            	  1361:                 move.l  d3,d0
00:00000EA4 51CAFFF0        	  1362:                 dbra    d2,.readloop
                            	  1363:         ; all done
00:00000EA8 7000            	  1364: .bufferfull:    moveq   #0,d0
                            	  1365: .error:         popm    d2-d3
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000EAA 4CDF000C        	     4M                 movem.l (sp)+,d2-d3
00:00000EAE 4E75            	  1366:                 rts
00:00000EB0 7026            	  1367: .badsector:     moveq   #FSERR_BADSECTOR,d0
00:00000EB2 60F6            	  1368:                 bra     .error
00:00000EB4 7025            	  1369: .invclstr:      moveq   #FSERR_INVCLSTR,d0
00:00000EB6 60F2            	  1370:                 bra     .error
                            	  1371: 
                            	  1372: 
                            	  1373: 
                            	  1374: ; Starting at the given cluster, load entire file from CF card.
                            	  1375: ; Arguments:    D0.W - cluster number
                            	  1376: ;               D1.L - size of destination memory buffer
                            	  1377: ;               A0.L - destination memory buffer
                            	  1378: ; Returns:      D0.B - error code (0 on success, nonzero on error)
                            	  1379: ;               A0.L - advanced
                            	  1380: ; note: A0 must be word-aligned
                            	  1381: fs_loadfileat:
00:00000EB8 3F00            	  1382:                 move.w  d0,-(sp)
00:00000EBA 61B4            	  1383:                 bsr     fs_loadcluster
00:00000EBC 6616            	  1384:                 bne     .error
00:00000EBE 4A81            	  1385:                 tst.l   d1      ; stop if buffer has been filled
00:00000EC0 6710            	  1386:                 beq     .done
                            	  1387:         ; look up next cluster in FAT
00:00000EC2 301F            	  1388:                 move.w  (sp)+,d0
00:00000EC4 6112            	  1389:                 bsr     fs_nextcluster
00:00000EC6 6B0C            	  1390:                 bmi     .error  ; msb set if there was an error
                            	  1391:         ; if cluster number >= $FFF8, reached the end
                            	  1392:         ; otherwise, read next cluster
00:00000EC8 B07CFFF8        	  1393:                 cmp.w   #$FFF8,d0
00:00000ECC 65EA            	  1394:                 bcs     fs_loadfileat
                            	  1395:         ; all done
00:00000ECE 7000            	  1396:                 moveq   #0,d0
00:00000ED0 4E75            	  1397:                 rts
00:00000ED2 7000            	  1398: .done:          moveq   #0,d0
00:00000ED4 544F            	  1399: .error:         addq    #2,sp
00:00000ED6 4E75            	  1400:                 rts
                            	  1401: 
                            	  1402: 
                            	  1403: ; Given a cluster number, finds the next cluster in the chain.
                            	  1404: ; Arguments:    D0.W - cluster number
                            	  1405: ; Returns:      D0.L - next cluster number, or error code
                            	  1406: ;                       if MSB of D0.L is 1, error code in D0.B
                            	  1407: ;                       if MSB of D0.L is 0, cluster number in D0.W
                            	  1408: ; A0 and D1 are preserved.
                            	  1409: ; Sectors are 512 bytes, so there are 256 FAT entries per cluster.
                            	  1410: ; Thus, the high byte of D0.W indicates the sector offset to fetch.
                            	  1411: fs_nextcluster: pushm   d1-d2/a0
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000ED8 48E76080        	     4M                 movem.l d1-d2/a0,-(sp)
00:00000EDC 3400            	  1412:                 move.w  d0,d2
00:00000EDE 223900E00026    	  1413:                 move.l  FATSECTOR,d1    ; get first sector of FAT
00:00000EE4 7000            	  1414:                 moveq   #0,d0
00:00000EE6 3002            	  1415:                 move.w  d2,d0           ; isolate lsb of cluster number
00:00000EE8 E048            	  1416:                 lsr.w   #8,d0
00:00000EEA D081            	  1417:                 add.l   d1,d0           ; add sector offset to FAT offset
                            	  1418:         ; read the appropriate sector of the FAT
00:00000EEC 4E56FE00        	  1419:                 link    a6,#-SECTORSIZE
00:00000EF0 204F            	  1420:                 move.l  sp,a0
00:00000EF2 72FF            	  1421:                 moveq   #-1,d1
                            	  1422:                 sys     ReadSector
00:00000EF4 4E47            	     1M                 trap    #ReadSector
00:00000EF6 4A40            	  1423:                 tst     d0
00:00000EF8 6616            	  1424:                 bne     .error
                            	  1425:         ; bring lsb of cluster number back to d0
00:00000EFA 7000            	  1426:                 moveq   #0,d0
00:00000EFC 1002            	  1427:                 move.b  d2,d0
                            	  1428:         ; table lookup
00:00000EFE D040            	  1429:                 add.w   d0,d0           ; multiply table index by 2 to get byte offset
00:00000F00 30370000        	  1430:                 move.w  (sp,d0.w),d0    ; get next cluster number from FAT
00:00000F04 E058            	  1431:                 ror.w   #8,d0           ; needs to be byteswapped
00:00000F06 4E5E            	  1432: .ret:           unlk    a6
                            	  1433:                 popm    d1-d2/a0
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000F08 4CDF0106        	     4M                 movem.l (sp)+,d1-d2/a0
00:00000F0C 4A80            	  1434:                 tst.l   d0
00:00000F0E 4E75            	  1435:                 rts
00:00000F10 08C0001F        	  1436: .error:         bset.l  #31,d0
00:00000F14 60F0            	  1437:                 bra     .ret
                            	  1438: 
                            	  1439: 
                            	  1440: ; Load the full contents of the named file from the CF card into memory.
                            	  1441: ; Arguments:    D0.L - size of destination memory buffer (-1 to load entire file)
                            	  1442: ;               A0.L - pointer to null-terminated 8.3 filename
                            	  1443: ;               A1.L - destination memory buffer
                            	  1444: ; Returns:      D0.B - error code (0 on success, nonzero on error)
                            	  1445: ;               D1.L - number of bytes read
                            	  1446: ;               A0.L - pointer to beginning of destination memory buffer (orig. value of A1)
                            	  1447: ; Will return an error if the named file is a directory.
                            	  1448: fs_loadfile:    pushm   d0/a1           ; save buffer size and address
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000F16 48E78040        	     4M                 movem.l d0/a1,-(sp)
00:00000F1A 4E56FFE0        	  1449:                 link    a6,#-DIRENTLEN  ; allocate buffer for directory entry
00:00000F1E 224F            	  1450:                 move.l  sp,a1
00:00000F20 6100FEFC        	  1451:                 bsr     fs_findfile
00:00000F24 662C            	  1452:                 bne     .finderror
00:00000F26 08290004000B    	  1453:                 btst.b  #4,FATTRS(a1)   ; is it a directory? can't load it.
00:00000F2C 662A            	  1454:                 bne     .isdir
00:00000F2E 3029001A        	  1455:                 move.w  FCLUSTER(a1),d0 ; get cluster number
00:00000F32 2229001C        	  1456:                 move.l  FSIZE(a1),d1    ; get file size
00:00000F36 6724            	  1457:                 beq     .emptyfile
00:00000F38 4E5E            	  1458:                 unlk    a6              ; discard directory entry
00:00000F3A B297            	  1459:                 cmp.l   (sp),d1         ; take minimum of buffer size and file size
00:00000F3C 6402            	  1460:                 bcc     .1
00:00000F3E 2E81            	  1461:                 move.l  d1,(sp)
                            	  1462: .1:             pop     d1              ; pop buffer size
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:00000F40 221F            	     4M                 move.l  (sp)+,d1
00:00000F42 2057            	  1463:                 move.l  (sp),a0         ; get buffer address, but keep on stack
00:00000F44 6100FF72        	  1464:                 bsr     fs_loadfileat   ; load the file!
00:00000F48 91D7            	  1465:                 sub.l   (sp),a0         ; compute number of bytes read
00:00000F4A 2208            	  1466:                 move.l  a0,d1           ; and move to return value in d1
                            	  1467:                 pop     a0              ; bring back original buffer address
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:00000F4C 205F            	     4M                 move.l  (sp)+,a0
00:00000F4E 4A00            	  1468:                 tst.b   d0
00:00000F50 4E75            	  1469:                 rts
00:00000F52 4E5E            	  1470: .finderror:     unlk    a6
00:00000F54 504F            	  1471:                 addq    #8,sp
00:00000F56 4E75            	  1472:                 rts
00:00000F58 7028            	  1473: .isdir:         moveq   #FSERR_ISDIR,d0
00:00000F5A 60F6            	  1474:                 bra     .finderror
                            	  1475:         ; return early if the file size is 0. an empty file has a cluster number
                            	  1476:         ; of zero, which will make fs_loadfileat report an invalid cluster.
                            	  1477:         ; instead, return successfully.
00:00000F5C 4E5E            	  1478: .emptyfile:     unlk    a6
                            	  1479:                 popm    d0/a1
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000F5E 4CDF0201        	     4M                 movem.l (sp)+,d0/a1
00:00000F62 7000            	  1480:                 moveq   #0,d0
00:00000F64 4E75            	  1481:                 rts
                            	  1482: 
                            	  1483: 
                            	  1484: ; Convert a "human-readable" filename to the 11-byte encoded filename string
                            	  1485: ; used in FAT16 directory entries. (e.g. "myfile.txt" -> "MYFILE  TXT").
                            	  1486: ; - lowercase ASCII characters converted to uppercase
                            	  1487: ; - filename padded to 8 characters and extension padded to 3 characters with spaces
                            	  1488: ; - period separating filename and extension is stripped out
                            	  1489: ; - aborts if input filename contains invalid characters
                            	  1490: ; Arguments:    A0.L - pointer to null-terminated input filename
                            	  1491: ;               A1.L - buffer where 11-byte encoded filename will be written to
                            	  1492: ; Returns:      D0.B - error code, or 0 if filename is valid
                            	  1493: ;               (A1) - if successful, populated with encoded filename
                            	  1494: ; The buffers pointed to by A0 and A1 should NOT overlap.
                            	  1495: fname_encode:   pushm   a0-a1
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000F66 48E700C0        	     4M                 movem.l a0-a1,-(sp)
                            	  1496:         ; start by filling the destination with spaces
00:00000F6A 700A            	  1497:                 moveq   #FNAMELEN-1,d0
00:00000F6C 7220            	  1498:                 moveq   #$20,d1
00:00000F6E 12C1            	  1499: .1:             move.b  d1,(a1)+
00:00000F70 51C8FFFC        	  1500:                 dbra    d0,.1
00:00000F74 43E9FFF5        	  1501:                 lea.l   -FNAMELEN(a1),a1
                            	  1502:         ; the empty string isn't a valid filename
00:00000F78 4A10            	  1503:                 tst.b   (a0)
00:00000F7A 6748            	  1504:                 beq     .invalid
                            	  1505:         ; populate filename
00:00000F7C 7200            	  1506:                 moveq   #0,d1
00:00000F7E 7007            	  1507: .filename:      moveq   #7,d0
00:00000F80 1218            	  1508: .fnameloop:     move.b  (a0)+,d1
00:00000F82 6738            	  1509:                 beq     .done           ; stop if we hit the null terminator
00:00000F84 B23C002E        	  1510:                 cmp.b   #'.',d1         ; if it's a period, jump to the extension
00:00000F88 6716            	  1511:                 beq     .extension
00:00000F8A 123B103C        	  1512:                 move.b  (validchartable,pc,d1.w),d1     ; case-convert and check for validity
00:00000F8E 6734            	  1513:                 beq     .invalid        ; if table entry is 0, character isn't allowed
00:00000F90 12C1            	  1514:                 move.b  d1,(a1)+        ; character is valid, store it
00:00000F92 51C8FFEC        	  1515:                 dbra    d0,.fnameloop
                            	  1516:         ; all 8 chars of filename have been populated--if next char in the
                            	  1517:         ; input string is not 0 or '.', the filename is invalid
00:00000F96 4A10            	  1518:                 tst.b   (a0)
00:00000F98 6722            	  1519:                 beq     .done
00:00000F9A 0C18002E        	  1520:                 cmp.b   #'.',(a0)+
00:00000F9E 6624            	  1521:                 bne     .invalid
                            	  1522:         ; populate extension
00:00000FA0 226F0004        	  1523: .extension:     move.l  4(sp),a1        ; grab pointer to start of dest buffer
00:00000FA4 5049            	  1524:                 addq    #8,a1           ; advance 8 bytes to start of extension
00:00000FA6 7002            	  1525:                 moveq   #2,d0
00:00000FA8 1218            	  1526: .extloop:       move.b  (a0)+,d1
00:00000FAA 6710            	  1527:                 beq     .done           ; stop if we hit the null terminator
00:00000FAC 123B101A        	  1528:                 move.b  (validchartable,pc,d1.w),d1     ; case-convert and check for validity
00:00000FB0 6712            	  1529:                 beq     .invalid        ; if table entry is 0, character isn't allowed
00:00000FB2 12C1            	  1530:                 move.b  d1,(a1)+        ; character is valid, store it
00:00000FB4 51C8FFF2        	  1531:                 dbra    d0,.extloop
                            	  1532:         ; all 3 chars of extension have been populated--if next char in the
                            	  1533:         ; input string is not 0, the filename is invalid
00:00000FB8 4A10            	  1534:                 tst.b   (a0)
00:00000FBA 6608            	  1535:                 bne     .invalid
                            	  1536:         ; filename is valid!
00:00000FBC 7000            	  1537: .done:          moveq   #0,d0
                            	  1538: .ret:           popm    a0-a1
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:00000FBE 205F225F        	     4M                 movem.l (sp)+,a0-a1
00:00000FC2 4E75            	  1539:                 rts
00:00000FC4 7027            	  1540: .invalid:       moveq   #FSERR_INVNAME,d0
00:00000FC6 60F6            	  1541:                 bra     .ret
                            	  1542: 
                            	  1543: validchartable:
                            	  1544: ;                       x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xA  xB  xC  xD  xE  xF
00:00000FC8 00              	  1545:                 dc.b    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
00:00000FC9 00
00:00000FCA 00
00:00000FCB 00
00:00000FCC 00
00:00000FCD 00
00:00000FCE 00
00:00000FCF 00
00:00000FD0 00
00:00000FD1 00
00:00000FD2 00
00:00000FD3 00
00:00000FD4 00
00:00000FD5 00
00:00000FD6 00
00:00000FD7 00
00:00000FD8 00              	  1546:                 dc.b    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
00:00000FD9 00
00:00000FDA 00
00:00000FDB 00
00:00000FDC 00
00:00000FDD 00
00:00000FDE 00
00:00000FDF 00
00:00000FE0 00
00:00000FE1 00
00:00000FE2 00
00:00000FE3 00
00:00000FE4 00
00:00000FE5 00
00:00000FE6 00
00:00000FE7 00
00:00000FE8 00              	  1547:                 dc.b    0,  '!',0,  '#','$','%','&',$27,'(',')',0,  0,  0,  '-',0,  0
00:00000FE9 21
00:00000FEA 00
00:00000FEB 23
00:00000FEC 24
00:00000FED 25
00:00000FEE 26
00:00000FEF 27
00:00000FF0 28
00:00000FF1 29
00:00000FF2 00
00:00000FF3 00
00:00000FF4 00
00:00000FF5 2D
00:00000FF6 00
00:00000FF7 00
00:00000FF8 30              	  1548:                 dc.b    '0','1','2','3','4','5','6','7','8','9',0,  0,  0,  0,  0,  0
00:00000FF9 31
00:00000FFA 32
00:00000FFB 33
00:00000FFC 34
00:00000FFD 35
00:00000FFE 36
00:00000FFF 37
00:00001000 38
00:00001001 39
00:00001002 00
00:00001003 00
00:00001004 00
00:00001005 00
00:00001006 00
00:00001007 00
00:00001008 40              	  1549:                 dc.b    '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'
00:00001009 41
00:0000100A 42
00:0000100B 43
00:0000100C 44
00:0000100D 45
00:0000100E 46
00:0000100F 47
00:00001010 48
00:00001011 49
00:00001012 4A
00:00001013 4B
00:00001014 4C
00:00001015 4D
00:00001016 4E
00:00001017 4F
00:00001018 50              	  1550:                 dc.b    'P','Q','R','S','T','U','V','W','X','Y','Z',0,  0,  0,  '^','_'
00:00001019 51
00:0000101A 52
00:0000101B 53
00:0000101C 54
00:0000101D 55
00:0000101E 56
00:0000101F 57
00:00001020 58
00:00001021 59
00:00001022 5A
00:00001023 00
00:00001024 00
00:00001025 00
00:00001026 5E
00:00001027 5F
00:00001028 60              	  1551:                 dc.b    '`','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'
00:00001029 41
00:0000102A 42
00:0000102B 43
00:0000102C 44
00:0000102D 45
00:0000102E 46
00:0000102F 47
00:00001030 48
00:00001031 49
00:00001032 4A
00:00001033 4B
00:00001034 4C
00:00001035 4D
00:00001036 4E
00:00001037 4F
00:00001038 50              	  1552:                 dc.b    'P','Q','R','S','T','U','V','W','X','Y','Z','{',0,  '}','~',0
00:00001039 51
00:0000103A 52
00:0000103B 53
00:0000103C 54
00:0000103D 55
00:0000103E 56
00:0000103F 57
00:00001040 58
00:00001041 59
00:00001042 5A
00:00001043 7B
00:00001044 00
00:00001045 7D
00:00001046 7E
00:00001047 00
00:00001048 80              	  1553:                 dc.b    $80,$81,$82,$83,$84,$85,$86,$87,$88,$89,$8A,$8B,$8C,$8D,$8E,$8F
00:00001049 81
00:0000104A 82
00:0000104B 83
00:0000104C 84
00:0000104D 85
00:0000104E 86
00:0000104F 87
00:00001050 88
00:00001051 89
00:00001052 8A
00:00001053 8B
00:00001054 8C
00:00001055 8D
00:00001056 8E
00:00001057 8F
00:00001058 90              	  1554:                 dc.b    $90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$9A,$9B,$9C,$9D,$9E,$9F
00:00001059 91
00:0000105A 92
00:0000105B 93
00:0000105C 94
00:0000105D 95
00:0000105E 96
00:0000105F 97
00:00001060 98
00:00001061 99
00:00001062 9A
00:00001063 9B
00:00001064 9C
00:00001065 9D
00:00001066 9E
00:00001067 9F
00:00001068 A0              	  1555:                 dc.b    $A0,$A1,$A2,$A3,$A4,$A5,$A6,$A7,$A8,$A9,$AA,$AB,$AC,$AD,$AE,$AF
00:00001069 A1
00:0000106A A2
00:0000106B A3
00:0000106C A4
00:0000106D A5
00:0000106E A6
00:0000106F A7
00:00001070 A8
00:00001071 A9
00:00001072 AA
00:00001073 AB
00:00001074 AC
00:00001075 AD
00:00001076 AE
00:00001077 AF
00:00001078 B0              	  1556:                 dc.b    $B0,$B1,$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9,$BA,$BB,$BC,$BD,$BE,$BF
00:00001079 B1
00:0000107A B2
00:0000107B B3
00:0000107C B4
00:0000107D B5
00:0000107E B6
00:0000107F B7
00:00001080 B8
00:00001081 B9
00:00001082 BA
00:00001083 BB
00:00001084 BC
00:00001085 BD
00:00001086 BE
00:00001087 BF
00:00001088 C0              	  1557:                 dc.b    $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF
00:00001089 C1
00:0000108A C2
00:0000108B C3
00:0000108C C4
00:0000108D C5
00:0000108E C6
00:0000108F C7
00:00001090 C8
00:00001091 C9
00:00001092 CA
00:00001093 CB
00:00001094 CC
00:00001095 CD
00:00001096 CE
00:00001097 CF
00:00001098 D0              	  1558:                 dc.b    $D0,$D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9,$DA,$DB,$DC,$DD,$DE,$DF
00:00001099 D1
00:0000109A D2
00:0000109B D3
00:0000109C D4
00:0000109D D5
00:0000109E D6
00:0000109F D7
00:000010A0 D8
00:000010A1 D9
00:000010A2 DA
00:000010A3 DB
00:000010A4 DC
00:000010A5 DD
00:000010A6 DE
00:000010A7 DF
00:000010A8 E0              	  1559:                 dc.b    $E0,$E1,$E2,$E3,$E4,0,  $E6,$E7,$E8,$E9,$EA,$EB,$EC,$ED,$EE,$EF
00:000010A9 E1
00:000010AA E2
00:000010AB E3
00:000010AC E4
00:000010AD 00
00:000010AE E6
00:000010AF E7
00:000010B0 E8
00:000010B1 E9
00:000010B2 EA
00:000010B3 EB
00:000010B4 EC
00:000010B5 ED
00:000010B6 EE
00:000010B7 EF
00:000010B8 F0              	  1560:                 dc.b    $F0,$F1,$F2,$F3,$F4,$F5,$F6,$F7,$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF
00:000010B9 F1
00:000010BA F2
00:000010BB F3
00:000010BC F4
00:000010BD F5
00:000010BE F6
00:000010BF F7
00:000010C0 F8
00:000010C1 F9
00:000010C2 FA
00:000010C3 FB
00:000010C4 FC
00:000010C5 FD
00:000010C6 FE
00:000010C7 FF
                            	  1561: 
                            	  1562: 
                            	  1563: 
                            	  1564: ; Convert a FAT16-encoded 11-byte filename to a "human-readable" representation.
                            	  1565: ; - space-padding in filename and extension removed, period added
                            	  1566: ; - null-terminator added
                            	  1567: ; Arguments:    A0.L - pointer to 11-byte encoded filename
                            	  1568: ;               A1.L - buffer where output filename will be written
                            	  1569: ; Returns:      (A1) - populated with decoded filename
                            	  1570: ; The buffers pointed to by A0 and A1 should NOT overlap.
                            	  1571: fname_decode:   pushm   a0-a1
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	     3M         endif
00:000010C8 48E700C0        	     4M                 movem.l a0-a1,-(sp)
                            	  1572:         ; skip trailing spaces in the filename portion
00:000010CC 5048            	  1573:                 addq    #8,a0
00:000010CE 7220            	  1574:                 moveq   #$20,d1
00:000010D0 7007            	  1575:                 moveq   #7,d0
00:000010D2 B220            	  1576: .1:             cmp.b   -(a0),d1
00:000010D4 6606            	  1577:                 bne     .2
00:000010D6 51C8FFFA        	  1578:                 dbra    d0,.1
                            	  1579:         ; filename portion was blank
00:000010DA 6008            	  1580:                 bra     .extension
                            	  1581: .2:     ; filename portion was not blank
00:000010DC 2057            	  1582:                 move.l  (sp),a0         ; bring back pointer to start of filename
00:000010DE 12D8            	  1583: .3:             move.b  (a0)+,(a1)+     ; copy filename to output buffer
00:000010E0 51C8FFFC        	  1584:                 dbra    d0,.3
                            	  1585: .extension:
                            	  1586:         ; check the file extension, if it's not blank, add a period
00:000010E4 2057            	  1587:                 move.l  (sp),a0         ; bring back pointer to start of filename
00:000010E6 41E8000B        	  1588:                 lea.l   FNAMELEN(a0),a0 ; advance to end of extension
00:000010EA 7220            	  1589:                 moveq   #$20,d1
00:000010EC 7002            	  1590:                 moveq   #2,d0
00:000010EE B220            	  1591: .4:             cmp.b   -(a0),d1
00:000010F0 6606            	  1592:                 bne     .5
00:000010F2 51C8FFFA        	  1593:                 dbra    d0,.4
                            	  1594:         ; extension was blank, don't add a period
00:000010F6 600E            	  1595:                 bra     .done
                            	  1596:         ; add the separating period
00:000010F8 12FC002E        	  1597: .5:             move.b  #'.',(a1)+
00:000010FC 2057            	  1598:                 move.l  (sp),a0         ; bring back pointer to start of filename
00:000010FE 5048            	  1599:                 addq    #8,a0           ; advance to start of extension
00:00001100 12D8            	  1600: .6:             move.b  (a0)+,(a1)+     ; copy extension to output buffer
00:00001102 51C8FFFC        	  1601:                 dbra    d0,.6
                            	  1602:         ; null-terminate
00:00001106 12FC0000        	  1603: .done:          move.b  #0,(a1)+
                            	  1604:                 popm    a0-a1
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	     3M         endif
00:0000110A 205F225F        	     4M                 movem.l (sp)+,a0-a1
00:0000110E 4E75            	  1605:                 rts
                            	  1606: 
                            	  1607: 
                            	  1608: 
                            	  1609: ;-------------------------------------------------------------------------------
                            	  1610: ; Bit-banged SPI interface.
                            	  1611: ;-------------------------------------------------------------------------------
                            	  1612: 
                            	  1613: ; Start a SPI transfer by asserting chip select.
                            	  1614: ; Arguments:    none
                            	  1615: ; Returns:      none
00:00001110 43F900A00008    	  1616: spi_startxfer:  lea.l   UART+MCR,a1
00:00001116 08910002        	  1617:                 bclr.b  #MCR_CLK,(a1)   ; clock starts high
00:0000111A 08D10003        	  1618:                 bset.b  #MCR_nSS,(a1)   ; chip select asserted
00:0000111E 4E75            	  1619:                 rts
                            	  1620: 
                            	  1621: ; End a SPI transfer by de-asserting chip select.
                            	  1622: ; Arguments:    none
                            	  1623: ; Returns:      none
00:00001120 43F900A00008    	  1624: spi_endxfer:    lea.l   UART+MCR,a1
00:00001126 08910003        	  1625:                 bclr.b  #MCR_nSS,(a1)   ; chip select deasserted
00:0000112A 4E75            	  1626:                 rts
                            	  1627: 
                            	  1628: ; Perform a 1-byte SPI data transfer.
                            	  1629: ; Arguments:    d0.b - data byte to shift out
                            	  1630: ; Returns:      d0.b - data byte shifted in
                            	  1631: spi_shiftbyte:  push    d2
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to push--use pushm if you want to push multiple registers
                            	     3M         endif
00:0000112C 2F02            	     4M                 move.l  d2,-(sp)
00:0000112E 43F900A00008    	  1632:                 lea.l   UART+MCR,a1
00:00001134 1411            	  1633:                 move.b  (a1),d2         ; use d2 as a temporary for MCR write operations
00:00001136 E20A            	  1634:                 lsr.b   #1,d2           ; delete bit 0 so we can shift our COPI bit in
00:00001138 4600            	  1635:                 not.b   d0              ; invert data byte to match MCR's inverted polarity
00:0000113A 7207            	  1636:                 moveq   #7,d1           ; eight bits
00:0000113C E310            	  1637: .bitloop:       roxl.b  #1,d0                   ; get data bit to send
00:0000113E E312            	  1638:                 roxl.b  #1,d2                   ; and rotate it into the COPI bit
00:00001140 5802            	  1639:                 addq.b  #(1<<MCR_CLK),d2        ; clock falling edge
00:00001142 1282            	  1640:                 move.b  d2,(a1)
00:00001144 5902            	  1641:                 subq.b  #(1<<MCR_CLK),d2        ; clock rising edge
00:00001146 1282            	  1642:                 move.b  d2,(a1)
00:00001148 E20A            	  1643:                 lsr.b   #1,d2           ; delete old COPI bit value
00:0000114A 4842            	  1644:                 swap    d2
00:0000114C 14290004        	  1645:                 move.b  4(a1),d2        ; read CIPO bit from MSR (2 words past MCR)
00:00001150 E30A            	  1646:                 lsl.b   #1,d2           ; rotate CIPO bit into X flag
00:00001152 4842            	  1647:                 swap    d2
00:00001154 51C9FFE6        	  1648:                 dbra    d1,.bitloop
00:00001158 E310            	  1649:                 roxl.b  #1,d0           ; rotate in the last bit received
00:0000115A 4600            	  1650:                 not.b   d0              ; invert CIPO bits
                            	  1651:                 pop     d2
                            	     1M         if NARG>1
                            	     2M         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	     3M         endif
00:0000115C 241F            	     4M                 move.l  (sp)+,d2
00:0000115E 4E75            	  1652:                 rts
                            	  1653: 
                            	  1654: printtime:      sys     GetDateTime
00:00001160 4E4B            	     1M                 trap    #GetDateTime
00:00001162 4A80            	  1655:                 tst.l   d0
00:00001164 6B18            	  1656:                 bmi     .timenotset
00:00001166 670E            	  1657:                 beq     .no_rtc
00:00001168 41F8165A        	  1658:                 lea.l   fmt_date,a0
00:0000116C 48E7C000        	  1659:                 movem.l d0-d1,-(sp)
                            	  1660:                 sys     OutFmt
00:00001170 4E44            	     1M                 trap    #OutFmt
00:00001172 504F            	  1661:                 addq    #8,sp
00:00001174 4E75            	  1662:                 rts
                            	  1663: 
00:00001176 41F81667        	  1664: .no_rtc:        lea.l   str_noclock,a0
                            	  1665:                 sys     OutStr
00:0000117A 4E43            	     1M                 trap    #OutStr
00:0000117C 4E75            	  1666:                 rts
00:0000117E 41F81684        	  1667: .timenotset:    lea.l   str_timenotset,a0
                            	  1668:                 sys     OutStr
00:00001182 4E43            	     1M                 trap    #OutStr
00:00001184 4E75            	  1669:                 rts
                            	  1670: 
                            	  1671: ;-------------------------------------------------------------------------------
                            	  1672: ; Serial I/O
                            	  1673: ;-------------------------------------------------------------------------------
00:00001186 43F900A00000    	  1674: uart_outchar:   lea.l   UART,a1
                            	  1675:                 tx_char d0,a1
                            	     1M                 tx_wait a1
00:0000118C 08290005000A    	     1M .t_000099:          btst.b  #5,LSR(a1)
00:00001192 67F8            	     2M                 beq     .t_000099
00:00001194 1280            	     2M                 move.b  d0,THR(a1)
00:00001196 4E75            	  1676:                 rts
                            	  1677: 
00:00001198 43F900A00000    	  1678: uart_inchar:    lea.l   UART,a1
00:0000119E 08290000000A    	  1679: .1:             btst.b  #0,LSR(a1)      ; char received?
00:000011A4 67F8            	  1680:                 beq     .1
00:000011A6 1011            	  1681:                 move.b  RHR(a1),d0      ; receive character
00:000011A8 4E75            	  1682:                 rts
                            	  1683: 
                            	  1684: ;-------------------------------------------------------------------------------
                            	  1685: ; Serial loader. Entered by UART interrupt
                            	  1686: ;-------------------------------------------------------------------------------
                            	  1687: ; Enter serial loader
                            	  1688: VEC_AUTOVEC1:
00:000011AA 43F900A00000    	  1689:                 lea.l   UART,a1
00:000011B0 08290004000A    	  1690:                 btst.b  #4,LSR(a1)      ; was this a break interrupt?
00:000011B6 6602            	  1691:                 bne     .1              ; if not, just return
00:000011B8 4E73            	  1692:                 rte
                            	  1693: ; wait for the break condition to deassert
00:000011BA 08290004000A    	  1694: .1:             btst.b  #4,LSR(a1)
00:000011C0 66F8            	  1695:                 bne     .1
                            	  1696: ; the break stuffs a zero byte into the fifo, remove it
00:000011C2 1011            	  1697:                 move.b  RHR(a1),d0
                            	  1698: ; acknowledge with 'U'
                            	  1699:                 tx_wait a1
00:000011C4 08290005000A    	     1M .t_000100:          btst.b  #5,LSR(a1)
00:000011CA 67F8            	     2M                 beq     .t_000100
00:000011CC 12BC0055        	  1700:                 move.b  #'U',THR(a1)
                            	  1701: ; now we're in the loader
00:000011D0 41F900E00100    	  1702:                 lea.l   APPMEMSTART,a0  ; starting RAM address
00:000011D6 7200            	  1703:                 moveq   #0,d1           ; byte counter
                            	  1704: ; receive characters in a loop and write them to RAM
00:000011D8 1029000A        	  1705: .byteloop:      move.b  LSR(a1),d0      ; wait for a character or a break from host
00:000011DC 08000004        	  1706:                 btst.l  #4,d0           ; break received?
00:000011E0 6614            	  1707:                 bne     .done           ; done with transfer
00:000011E2 08000000        	  1708:                 btst.l  #0,d0           ; character received?
00:000011E6 67F0            	  1709:                 beq     .byteloop
00:000011E8 10D1            	  1710:                 move.b  RHR(a1),(a0)+   ; receive byte and write to RAM
00:000011EA 5201            	  1711:                 addq.b  #1,d1           ; increment byte count
00:000011EC 66EA            	  1712:                 bne     .byteloop
00:000011EE 086900010008    	  1713:                 bchg.b  #MCR_LED,MCR(a1) ; flash LED every 256 bytes (each time byte count lsb is zero)
00:000011F4 60E2            	  1714:                 bra     .byteloop
                            	  1715: .done:
                            	  1716: ; wait for the break condition to deassert
00:000011F6 08290004000A    	  1717: .2:             btst.b  #4,LSR(a1)
00:000011FC 66F8            	  1718:                 bne     .2
                            	  1719: ; the break stuffs a zero byte into the fifo, remove it
00:000011FE 1011            	  1720:                 move.b  RHR(a1),d0
                            	  1721: ; turn off LED and jump to application
00:00001200 08A900010008    	  1722: launchapp:      bclr.b  #MCR_LED,MCR(a1)
00:00001206 7000            	  1723:                 moveq   #0,d0           ; zero all registers
00:00001208 2200            	  1724:                 move.l  d0,d1
00:0000120A 2400            	  1725:                 move.l  d0,d2
00:0000120C 2600            	  1726:                 move.l  d0,d3
00:0000120E 2800            	  1727:                 move.l  d0,d4
00:00001210 2A00            	  1728:                 move.l  d0,d5
00:00001212 2C00            	  1729:                 move.l  d0,d6
00:00001214 2E00            	  1730:                 move.l  d0,d7
00:00001216 2040            	  1731:                 move.l  d0,a0
00:00001218 2240            	  1732:                 move.l  d0,a1
00:0000121A 2440            	  1733:                 move.l  d0,a2
00:0000121C 2640            	  1734:                 move.l  d0,a3
00:0000121E 2840            	  1735:                 move.l  d0,a4
00:00001220 2A40            	  1736:                 move.l  d0,a5
00:00001222 2C40            	  1737:                 move.l  d0,a6
00:00001224 2E7C00F00000    	  1738:                 move.l  #INITIAL_SP,sp  ; reset stack pointer
00:0000122A 46FC2000        	  1739:                 move.w  #$2000,sr       ; enable interrupts
00:0000122E 4EF900E00100    	  1740:                 jmp     APPMEMSTART     ; begin execution from RAM
                            	  1741: 
                            	  1742: 
                            	  1743: 
                            	  1744: ; Arg 0: exception name (string)
                            	  1745: ; Arg 1: exception group (0, 1, or 2. see Table 5-3 "Exception Grouping and Priority")
                            	  1746: vecstub         macro
                            	  1747:                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
                            	  1748:                 lea.l   (.str,pc),a0
                            	  1749:                 bra     crash
                            	  1750:         .str:   dc.w    $0A2A
                            	  1751:                 asciz   \1
                            	  1752:                 even
                            	  1753:                 endm
                            	  1754: 
                            	  1755: g0stub          macro
                            	  1756:                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
                            	  1757:                 lea.l   (.str,pc),a0
                            	  1758:                 bra     grp0_crash
                            	  1759:         .str:   dc.w    $0A2A
                            	  1760:                 asciz   \1
                            	  1761:                 even
                            	  1762:                 endm
                            	  1763: 
                            	  1764: VEC_BUSFAULT:   g0stub  "BUS FAULT"
00:00001234 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001238 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:0000123C 60000236        	     3M                 bra     grp0_crash
00:00001240 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "BUS FAULT"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001242 425553204641554C	     1M                 dc.b    "BUS FAULT"
00:0000124A 54
                            	     2M                 
00:0000124B 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1765: VEC_ADRERROR:   g0stub  "ADDRESS ERROR"
00:0000124C 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001250 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:00001254 6000021E        	     3M                 bra     grp0_crash
00:00001258 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "ADDRESS ERROR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000125A 4144445245535320	     1M                 dc.b    "ADDRESS ERROR"
00:00001262 4552524F52
                            	     2M                 
00:00001267 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1766: VEC_ILLINSTR:   vecstub "ILLEGAL INSTRUCTION"
00:00001268 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:0000126C 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:00001270 600001F8        	     3M                 bra     crash
00:00001274 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "ILLEGAL INSTRUCTION"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001276 494C4C4547414C20	     1M                 dc.b    "ILLEGAL INSTRUCTION"
00:0000127E 494E535452554354
00:00001286 494F4E
                            	     2M                 
00:00001289 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1767: VEC_DIVBY0:     vecstub "ZERO DIVIDE"
00:0000128A 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:0000128E 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:00001292 600001D6        	     3M                 bra     crash
00:00001296 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "ZERO DIVIDE"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001298 5A45524F20444956	     1M                 dc.b    "ZERO DIVIDE"
00:000012A0 494445
                            	     2M                 
00:000012A3 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1768: VEC_CHK:        vecstub "CHK"
00:000012A4 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000012A8 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000012AC 600001BC        	     3M                 bra     crash
00:000012B0 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "CHK"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000012B2 43484B          	     1M                 dc.b    "CHK"
                            	     2M                 
00:000012B5 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1769: VEC_TRAPV:      vecstub "TRAPV"
00:000012B6 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000012BA 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000012BE 600001AA        	     3M                 bra     crash
00:000012C2 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "TRAPV"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000012C4 5452415056      	     1M                 dc.b    "TRAPV"
                            	     2M                 
00:000012C9 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1770: VEC_PRIVVIOL:   vecstub "PRIVILEGE VIOLATION"
00:000012CA 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000012CE 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000012D2 60000196        	     3M                 bra     crash
00:000012D6 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "PRIVILEGE VIOLATION"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000012D8 50524956494C4547	     1M                 dc.b    "PRIVILEGE VIOLATION"
00:000012E0 452056494F4C4154
00:000012E8 494F4E
                            	     2M                 
00:000012EB 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1771: VEC_TRACE:      vecstub "TRACE"
00:000012EC 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000012F0 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000012F4 60000174        	     3M                 bra     crash
00:000012F8 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "TRACE"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000012FA 5452414345      	     1M                 dc.b    "TRACE"
                            	     2M                 
00:000012FF 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1772: VEC_LINE1010:   vecstub "LINE 1010 EMULATOR"
00:00001300 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001304 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:00001308 60000160        	     3M                 bra     crash
00:0000130C 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "LINE 1010 EMULATOR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000130E 4C494E4520313031	     1M                 dc.b    "LINE 1010 EMULATOR"
00:00001316 3020454D554C4154
00:0000131E 4F52
                            	     2M                 
00:00001320 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1773: VEC_LINE1111:   vecstub "LINE 1111 EMULATOR"
00:00001322 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001326 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:0000132A 6000013E        	     3M                 bra     crash
00:0000132E 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "LINE 1111 EMULATOR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001330 4C494E4520313131	     1M                 dc.b    "LINE 1111 EMULATOR"
00:00001338 3120454D554C4154
00:00001340 4F52
                            	     2M                 
00:00001342 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1774: VEC_RESERVED:   vecstub "RESERVED VECTOR"
00:00001344 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001348 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:0000134C 6000011C        	     3M                 bra     crash
00:00001350 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "RESERVED VECTOR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001352 5245534552564544	     1M                 dc.b    "RESERVED VECTOR"
00:0000135A 20564543544F52
                            	     2M                 
00:00001361 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1775: VEC_UNINIVEC:   vecstub "UNINITIALIZED INTERRUPT VECTOR"
00:00001362 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001366 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:0000136A 600000FE        	     3M                 bra     crash
00:0000136E 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "UNINITIALIZED INTERRUPT VECTOR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001370 554E494E49544941	     1M                 dc.b    "UNINITIALIZED INTERRUPT VECTOR"
00:00001378 4C495A454420494E
00:00001380 5445525255505420
00:00001388 564543544F52
                            	     2M                 
00:0000138E 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1776: VEC_SPURIOUS:   vecstub "SPURIOUS INTERRUPT"
00:00001390 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001394 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:00001398 600000D0        	     3M                 bra     crash
00:0000139C 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "SPURIOUS INTERRUPT"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000139E 53505552494F5553	     1M                 dc.b    "SPURIOUS INTERRUPT"
00:000013A6 20494E5445525255
00:000013AE 5054
                            	     2M                 
00:000013B0 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1777: VEC_AUTOVEC2:   vecstub "AUTOVECTOR 2"
00:000013B2 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000013B6 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000013BA 600000AE        	     3M                 bra     crash
00:000013BE 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 2"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000013C0 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 2"
00:000013C8 4F522032
                            	     2M                 
00:000013CC 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1778: VEC_AUTOVEC3:   vecstub "AUTOVECTOR 3"
00:000013CE 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000013D2 41FA0006        	     2M                 lea.l   (.str,pc),a0
00:000013D6 60000092        	     3M                 bra     crash
00:000013DA 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 3"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000013DC 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 3"
00:000013E4 4F522033
                            	     2M                 
00:000013E8 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1779: VEC_AUTOVEC4:   vecstub "AUTOVECTOR 4"
00:000013EA 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:000013EE 41FA0004        	     2M                 lea.l   (.str,pc),a0
00:000013F2 6076            	     3M                 bra     crash
00:000013F4 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 4"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000013F6 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 4"
00:000013FE 4F522034
                            	     2M                 
00:00001402 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1780: VEC_AUTOVEC5:   vecstub "AUTOVECTOR 5"
00:00001404 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001408 41FA0004        	     2M                 lea.l   (.str,pc),a0
00:0000140C 605C            	     3M                 bra     crash
00:0000140E 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 5"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001410 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 5"
00:00001418 4F522035
                            	     2M                 
00:0000141C 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1781: VEC_AUTOVEC6:   vecstub "AUTOVECTOR 6"
00:0000141E 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001422 41FA0004        	     2M                 lea.l   (.str,pc),a0
00:00001426 6042            	     3M                 bra     crash
00:00001428 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 6"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000142A 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 6"
00:00001432 4F522036
                            	     2M                 
00:00001436 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1782: VEC_AUTOVEC7:   vecstub "AUTOVECTOR 7"
00:00001438 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:0000143C 41FA0004        	     2M                 lea.l   (.str,pc),a0
00:00001440 6028            	     3M                 bra     crash
00:00001442 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "AUTOVECTOR 7"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001444 4155544F56454354	     1M                 dc.b    "AUTOVECTOR 7"
00:0000144C 4F522037
                            	     2M                 
00:00001450 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1783: VEC_BREAKPT:    vecstub "BREAKPOINT"
00:00001452 48E7FFFF        	     1M                 movem.l d0-d7/a0-a7,-(sp)       ; stack all the registers
00:00001456 41FA0004        	     2M                 lea.l   (.str,pc),a0
00:0000145A 600E            	     3M                 bra     crash
00:0000145C 0A2A            	     4M         .str:   dc.w    $0A2A
                            	     5M                 asciz   "BREAKPOINT"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000145E 425245414B504F49	     1M                 dc.b    "BREAKPOINT"
00:00001466 4E54
                            	     2M                 
00:00001468 00              	     4M                 dc.b    0
                            	     5M                 even
                            	     6M                 even
                            	  1784: 
                            	  1785: ;-------------------------------------------------------------------------------
                            	  1786: ; Dump registers and hang.
                            	  1787: ; a0 - pointer to null-terminated exception name string
                            	  1788: ; d7 - number of bytes to unstack when resuming
                            	  1789: ;-------------------------------------------------------------------------------
                            	  1790: crash:          sys     OutStr
00:0000146A 4E43            	     1M                 trap    #OutStr
00:0000146C 41F8152B        	  1791:                 lea.l   fmt_regs,a0
00:00001470 7E40            	  1792:                 moveq   #64,d7          ; need to unstack 16 longwords
00:00001472 6008            	  1793:                 bra     dumpregs
                            	  1794: 
                            	  1795: grp0_crash:     sys     OutStr
00:00001474 4E43            	     1M                 trap    #OutStr
00:00001476 41F815A1        	  1796:                 lea.l   fmt_grp0regs,a0
00:0000147A 7E48            	  1797:                 moveq   #72,d7          ; need to unstack 16 longwords and 4 words from the group 0 exception frame
                            	  1798: 
                            	  1799: dumpregs:       sys     OutFmt          ; print D regs, A regs, and exception frame
00:0000147C 4E44            	     1M                 trap    #OutFmt
00:0000147E 4E68            	  1800:                 move.l  usp,a0          ; print user stack pointer
00:00001480 2F08            	  1801:                 move.l  a0,-(sp)
00:00001482 41F8162D        	  1802:                 lea.l   fmt_usp,a0
                            	  1803:                 sys     OutFmt
00:00001486 4E44            	     1M                 trap    #OutFmt
00:00001488 584F            	  1804:                 addq    #4,sp
                            	  1805:                 bra     prompt
                            	  1806: 
00:0000148A 41F8150E        	  1807: prompt:         lea.l   debugprompt,a0
                            	  1808:                 sys     OutStr
00:0000148E 4E43            	     1M                 trap    #OutStr
00:00001490 0839000000A0000A	  1809: .waitchar:      btst.b  #0,UART+LSR
00:00001498 6614            	  1810:                 bne     .gotchar
                            	  1811:                 led_tgl
00:0000149A 0879000100A00008	     1M                 bchg.b  #MCR_LED,UART+MCR
                            	  1812:                 spin    $8000
00:000014A2 203C00008000    	     1M                 move.l  #$8000,d0
00:000014A8 51C8FFFE        	     2M .spin_000167:        dbra    d0,.spin_000167
00:000014AC 60E2            	  1813:                 bra     .waitchar
00:000014AE 103900A00000    	  1814: .gotchar:       move.b  UART+RHR,d0
                            	  1815:                 sys     OutChar
00:000014B4 4E42            	     1M                 trap    #OutChar
00:000014B6 B03C0041        	  1816:                 cmp.b   #'A',d0         ; a: abort
00:000014BA 6700EE02        	  1817:                 beq     ready
00:000014BE B03C0061        	  1818:                 cmp.b   #'a',d0
00:000014C2 6700EDFA        	  1819:                 beq     ready
00:000014C6 B03C0043        	  1820:                 cmp.b   #'C',d0         ; c: continue
00:000014CA 671A            	  1821:                 beq     resume
00:000014CC B03C0063        	  1822:                 cmp.b   #'c',d0         ; c: continue
00:000014D0 6714            	  1823:                 beq     resume
00:000014D2 B03C0053        	  1824:                 cmp.b   #'S',d0
00:000014D6 6706            	  1825:                 beq     resume_traceon
00:000014D8 B03C0073        	  1826:                 cmp.b   #'s',d0
00:000014DC 66AC            	  1827:                 bne     prompt
                            	  1828: resume_traceon:
00:000014DE DFC7            	  1829:                 add.l   d7,sp
00:000014E0 00578000        	  1830:                 or.w    #$8000,(sp) ; set Trace flag
00:000014E4 4E73            	  1831:                 rte                     ; attempt to resume
                            	  1832: ; attempt to resume
00:000014E6 DFC7            	  1833: resume:         add.l   d7,sp
00:000014E8 02577FFF        	  1834:                 and.w   #$7FFF,(sp)        ; make sure Trace flag is clear
00:000014EC 4E73            	  1835:                 rte
                            	  1836: 
00:000014EE 3031323334353637	  1837: hexdigits_uc:   dc.b    "0123456789ABCDEF"
00:000014F6 3839414243444546
00:000014FE 3031323334353637	  1838: hexdigits_lc:   dc.b    "0123456789abcdef"
00:00001506 3839616263646566
00:0000150E 0A5B415D424F5254	  1839: debugprompt:    dc.b    "\n[A]BORT/[C]ONTINUE/[S]TEP? ",0
00:00001516 2F5B435D4F4E5449
00:0000151E 4E55452F5B535D54
00:00001526 45503F20
00:0000152A 00
00:0000152B 0A44303D        	  1840: fmt_regs:       dc.b    "\nD0=",FMT_H32,"  D1=",FMT_H32,"  D2=",FMT_H32,"  D3=",FMT_H32,"\n"
00:0000152F E5
00:00001530 202044313D
00:00001535 E5
00:00001536 202044323D
00:0000153B E5
00:0000153C 202044333D
00:00001541 E5
00:00001542 0A
00:00001543 44343D          	  1841:                 dc.b    "D4=",FMT_H32,"  D5=",FMT_H32,"  D6=",FMT_H32,"  D7=",FMT_H32,"\n"
00:00001546 E5
00:00001547 202044353D
00:0000154C E5
00:0000154D 202044363D
00:00001552 E5
00:00001553 202044373D
00:00001558 E5
00:00001559 0A
00:0000155A 41303D          	  1842:                 dc.b    "A0=",FMT_H32,"  A1=",FMT_H32,"  A2=",FMT_H32,"  A3=",FMT_H32,"\n"
00:0000155D E5
00:0000155E 202041313D
00:00001563 E5
00:00001564 202041323D
00:00001569 E5
00:0000156A 202041333D
00:0000156F E5
00:00001570 0A
00:00001571 41343D          	  1843:                 dc.b    "A4=",FMT_H32,"  A5=",FMT_H32,"  A6=",FMT_H32,"  A7=",FMT_H32,"\n"
00:00001574 E5
00:00001575 202041353D
00:0000157A E5
00:0000157B 202041363D
00:00001580 E5
00:00001581 202041373D
00:00001586 E5
00:00001587 0A
00:00001588 53523D          	  1844:                 dc.b    "SR=",FMT_SRFLAGS,"  PC=",FMT_H32,"              ", 0
00:0000158B F0
00:0000158C 202050433D
00:00001591 E5
00:00001592 2020202020202020
00:0000159A 202020202020
00:000015A0 00
                            	  1845: 
00:000015A1 0A44303D        	  1846: fmt_grp0regs:   dc.b    "\nD0=",FMT_H32,"  D1=",FMT_H32,"  D2=",FMT_H32,"  D3=",FMT_H32,"\n"
00:000015A5 E5
00:000015A6 202044313D
00:000015AB E5
00:000015AC 202044323D
00:000015B1 E5
00:000015B2 202044333D
00:000015B7 E5
00:000015B8 0A
00:000015B9 44343D          	  1847:                 dc.b    "D4=",FMT_H32,"  D5=",FMT_H32,"  D6=",FMT_H32,"  D7=",FMT_H32,"\n"
00:000015BC E5
00:000015BD 202044353D
00:000015C2 E5
00:000015C3 202044363D
00:000015C8 E5
00:000015C9 202044373D
00:000015CE E5
00:000015CF 0A
00:000015D0 41303D          	  1848:                 dc.b    "A0=",FMT_H32,"  A1=",FMT_H32,"  A2=",FMT_H32,"  A3=",FMT_H32,"\n"
00:000015D3 E5
00:000015D4 202041313D
00:000015D9 E5
00:000015DA 202041323D
00:000015DF E5
00:000015E0 202041333D
00:000015E5 E5
00:000015E6 0A
00:000015E7 41343D          	  1849:                 dc.b    "A4=",FMT_H32,"  A5=",FMT_H32,"  A6=",FMT_H32,"  A7=",FMT_H32,"\n"
00:000015EA E5
00:000015EB 202041353D
00:000015F0 E5
00:000015F1 202041363D
00:000015F6 E5
00:000015F7 202041373D
00:000015FC E5
00:000015FD 0A
00:000015FE 464C4147533D    	  1850:                 dc.b    "FLAGS=",FMT_FAULTFLAGS,"  ADDR=",FMT_H32,"  IR=",FMT_H16,"\n"
00:00001604 F1
00:00001605 2020414444523D
00:0000160C E5
00:0000160D 202049523D
00:00001612 E4
00:00001613 0A
00:00001614 53523D          	  1851:                 dc.b    "SR=",FMT_SRFLAGS,"  PC=",FMT_H32,"              ", 0
00:00001617 F0
00:00001618 202050433D
00:0000161D E5
00:0000161E 2020202020202020
00:00001626 202020202020
00:0000162C 00
00:0000162D 5553503D        	  1852: fmt_usp:        dc.b    "USP=",FMT_H32,"\n",0
00:00001631 E5
00:00001632 0A
00:00001633 00
                            	  1853: 
00:00001634 0A52414D3A20    	  1854: fmt_sysinfo:    dc.b    "\nRAM: ",FMT_U32," BYTES\nROM: ",FMT_U32," BYTES\nCPU: ",FMT_U32," HZ\n",0
00:0000163A E9
00:0000163B 2042595445530A52
00:00001643 4F4D3A20
00:00001647 E9
00:00001648 2042595445530A43
00:00001650 50553A20
00:00001654 E9
00:00001655 20485A0A
00:00001659 00
00:0000165A 54494D4520495320	  1855: fmt_date:       dc.b    "TIME IS ",FMT_DATE," ",FMT_TIME,"\n",0
00:00001662 F2
00:00001663 20
00:00001664 F3
00:00001665 0A
00:00001666 00
                            	  1856: str_noclock:    asciz   "NO REAL-TIME CLOCK DETECTED\n"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001667 4E4F205245414C2D	     1M                 dc.b    "NO REAL-TIME CLOCK DETECTED\n"
00:0000166F 54494D4520434C4F
00:00001677 434B204445544543
00:0000167F 5445440A
                            	     2M                 
00:00001683 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1857: str_timenotset: asciz   "DATE/TIME NOT SET\n"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001684 444154452F54494D	     1M                 dc.b    "DATE/TIME NOT SET\n"
00:0000168C 45204E4F54205345
00:00001694 540A
                            	     2M                 
00:00001696 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1858:                 even
                            	  1859: 
                            	  1860: ; CF card and filesystem error strings
                            	  1861: fserr_noerror:  asciz   "NO ERROR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001698 4E4F204552524F52	     1M                 dc.b    "NO ERROR"
                            	     2M                 
00:000016A0 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1862: fserr_amnf:     asciz   "CARD ERROR: ADDRESS MARK NOT FOUND"            ; CF error register bit 0 set
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000016A2 4341524420455252	     1M                 dc.b    "CARD ERROR: ADDRESS MARK NOT FOUND"
00:000016AA 4F523A2041444452
00:000016B2 455353204D41524B
00:000016BA 204E4F5420464F55
00:000016C2 4E44
                            	     2M                 
00:000016C4 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1863: fserr_abrt:     asciz   "CARD ERROR: COMMAND ABORTED"                   ; CF error register bit 2 set
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000016C6 4341524420455252	     1M                 dc.b    "CARD ERROR: COMMAND ABORTED"
00:000016CE 4F523A20434F4D4D
00:000016D6 414E442041424F52
00:000016DE 544544
                            	     2M                 
00:000016E1 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1864: fserr_idnf:     asciz   "CARD ERROR: INVALID SECTOR ID"                 ; CF error register bit 4 set
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000016E2 4341524420455252	     1M                 dc.b    "CARD ERROR: INVALID SECTOR ID"
00:000016EA 4F523A20494E5641
00:000016F2 4C49442053454354
00:000016FA 4F52204944
                            	     2M                 
00:000016FF 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1865: fserr_unc:      asciz   "CARD ERROR: UNCORRECTABLE ERROR DETECTED"      ; CF error register bit 6 set
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001700 4341524420455252	     1M                 dc.b    "CARD ERROR: UNCORRECTABLE ERROR DETECTED"
00:00001708 4F523A20554E434F
00:00001710 525245435441424C
00:00001718 45204552524F5220
00:00001720 4445544543544544
                            	     2M                 
00:00001728 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1866: fserr_bbk:      asciz   "CARD ERROR: BAD BLOCK DETECTED"                ; CF error register bit 7 set
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000172A 4341524420455252	     1M                 dc.b    "CARD ERROR: BAD BLOCK DETECTED"
00:00001732 4F523A2042414420
00:0000173A 424C4F434B204445
00:00001742 544543544544
                            	     2M                 
00:00001748 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1867: fserr_nocard:   asciz   "NO CARD DETECTED"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000174A 4E4F204341524420	     1M                 dc.b    "NO CARD DETECTED"
00:00001752 4445544543544544
                            	     2M                 
00:0000175A 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1868: fserr_notfat16: asciz   "INVALID CARD FORMAT (NOT FAT16)"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000175C 494E56414C494420	     1M                 dc.b    "INVALID CARD FORMAT (NOT FAT16)"
00:00001764 4341524420464F52
00:0000176C 4D415420284E4F54
00:00001774 20464154313629
                            	     2M                 
00:0000177B 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1869: fserr_not512:   asciz   "INVALID CARD FORMAT (LARGE SECTORS NOT SUPPORTED)"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:0000177C 494E56414C494420	     1M                 dc.b    "INVALID CARD FORMAT (LARGE SECTORS NOT SUPPORTED)"
00:00001784 4341524420464F52
00:0000178C 4D415420284C4152
00:00001794 474520534543544F
00:0000179C 5253204E4F542053
00:000017A4 5550504F52544544
00:000017AC 29
                            	     2M                 
00:000017AD 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1870: fserr_nmounted: asciz   "CARD NOT MOUNTED"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000017AE 43415244204E4F54	     1M                 dc.b    "CARD NOT MOUNTED"
00:000017B6 204D4F554E544544
                            	     2M                 
00:000017BE 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1871: fserr_notfound: asciz   "FILE NOT FOUND"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000017C0 46494C45204E4F54	     1M                 dc.b    "FILE NOT FOUND"
00:000017C8 20464F554E44
                            	     2M                 
00:000017CE 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1872: fserr_invclstr: asciz   "INVALID CLUSTER NUMBER"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000017D0 494E56414C494420	     1M                 dc.b    "INVALID CLUSTER NUMBER"
00:000017D8 434C555354455220
00:000017E0 4E554D424552
                            	     2M                 
00:000017E6 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1873: fserr_badsectr: asciz   "BAD SECTOR"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000017E8 4241442053454354	     1M                 dc.b    "BAD SECTOR"
00:000017F0 4F52
                            	     2M                 
00:000017F2 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1874: fserr_invname:  asciz   "INVALID FILENAME"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:000017F4 494E56414C494420	     1M                 dc.b    "INVALID FILENAME"
00:000017FC 46494C454E414D45
                            	     2M                 
00:00001804 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1875: fserr_isdir:    asciz   "IS A DIRECTORY"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001806 4953204120444952	     1M                 dc.b    "IS A DIRECTORY"
00:0000180E 4543544F5259
                            	     2M                 
00:00001814 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1876: fserr_other:    asciz   "CARD ERROR: OTHER"
                            	     1M                 rept    1
                            	     2M                 dc.b    \+
                            	     3M                 endr
00:00001816 4341524420455252	     1M                 dc.b    "CARD ERROR: OTHER"
00:0000181E 4F523A204F544845
00:00001826 52
                            	     2M                 
00:00001827 00              	     4M                 dc.b    0
                            	     5M                 even
                            	  1877: 
00:00001828 00001698        	  1878: fserrtable:     dc.l    fserr_noerror           ; 0
00:0000182C 000016A2        	  1879:                 dc.l    fserr_amnf              ; 1
00:00001830 00001816        	  1880:                 dc.l    fserr_other             ; 2
00:00001834 00001816        	  1881:                 dc.l    fserr_other             ; 3
00:00001838 000016C6        	  1882:                 dc.l    fserr_abrt              ; 4
00:0000183C 00001816        	  1883:                 dcb.l   16-((*-fserrtable)/4),fserr_other
00:00001840 *
00:00001868 000016E2        	  1884:                 dc.l    fserr_idnf              ; 16
00:0000186C 00000000        	  1885:                 dcb.l   FSERR_TIMEOUT-((*-fserrtable)/4)
00:00001870 *
00:000018A8 0000174A        	  1886:                 dc.l    fserr_nocard            ; 32 (FSERR_TIMEOUT)
00:000018AC 0000175C        	  1887:                 dc.l    fserr_notfat16          ; 33 (FSERR_WRONGTYPE)
00:000018B0 0000177C        	  1888:                 dc.l    fserr_not512            ; 34 (FSERR_BPS)
00:000018B4 000017AE        	  1889:                 dc.l    fserr_nmounted          ; 35 (FSERR_NMOUNTED)
00:000018B8 000017C0        	  1890:                 dc.l    fserr_notfound          ; 36 (FSERR_NOTFOUND)
00:000018BC 000017D0        	  1891:                 dc.l    fserr_invclstr          ; 37 (FSERR_INVCLSTR)
00:000018C0 000017E8        	  1892:                 dc.l    fserr_badsectr          ; 38 (FSERR_BADSECTOR)
00:000018C4 000017F4        	  1893:                 dc.l    fserr_invname           ; 39 (FSERR_INVNAME)
00:000018C8 00001806        	  1894:                 dc.l    fserr_isdir             ; 40 (FSERR_ISDIR)
00:000018CC 00001816        	  1895:                 dcb.l   64-((*-fserrtable)/4),fserr_other
00:000018D0 *
00:00001928 00001700        	  1896:                 dc.l    fserr_unc               ; 64
00:0000192C 00001816        	  1897:                 dcb.l   128-((*-fserrtable)/4),fserr_other
00:00001930 *
00:00001A28 0000172A        	  1898:                 dc.l    fserr_bbk               ; 128
00:00001A2C 00001816        	  1899:                 dcb.l   256-((*-fserrtable)/4),fserr_other
00:00001A30 *
                            	  1900: 
                            	  1901: 
                            	  1902: 
                            	  1903: ;-------------------------------------------------------------------------------
                            	  1904: ; Shell (command interpreter)
                            	  1905: ;-------------------------------------------------------------------------------
                            	  1906: loadaddr        equ     APPMEMSTART
                            	  1907: loadlen         equ     RAMEND-loadaddr-256     ; leave 256 bytes for the stack
                            	  1908: startshell:     litstr  "\nTYPE ? [ENTER] FOR HELP."
00:00001C28 41FA0004        	     1M                 lea.l   (.str_000205,pc),a0
00:00001C2C 601A            	     2M                 bra     .next_000205
                            	     3M .str_000205:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001C2E 0A54595045203F20	     1M                 dc.b    "\nTYPE ? [ENTER] FOR HELP."
00:00001C36 5B454E5445525D20
00:00001C3E 464F522048454C50
00:00001C46 2E
                            	     2M                 
00:00001C47 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000205:
                            	  1909:                 sys     OutStr
00:00001C48 4E43            	     1M                 trap    #OutStr
                            	  1910: shell:          litstr  "\n> "
00:00001C4A 41FA0004        	     1M                 lea.l   (.str_000208,pc),a0
00:00001C4E 6004            	     2M                 bra     .next_000208
                            	     3M .str_000208:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001C50 0A3E20          	     1M                 dc.b    "\n> "
                            	     2M                 
00:00001C53 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000208:
                            	  1911:                 sys     OutStr
00:00001C54 4E43            	     1M                 trap    #OutStr
00:00001C56 41F900E0003A    	  1912:                 lea.l   INPUTBUF,a0
00:00001C5C 7040            	  1913:                 moveq   #INPUTBUFLEN,d0
00:00001C5E 720A            	  1914:                 moveq   #$0a,d1
                            	  1915:                 sys     PromptStr
00:00001C60 4E46            	     1M                 trap    #PromptStr
00:00001C62 4A80            	  1916:                 tst.l   d0
00:00001C64 67E4            	  1917:                 beq     shell
                            	  1918:         ; does it begin with a question mark? if so, print help
00:00001C66 1018            	  1919:                 move.b  (a0)+,d0
00:00001C68 B03C003F        	  1920:                 cmp.b   #'?',d0
00:00001C6C 670001DC        	  1921:                 beq     help
                            	  1922:         ; otherwise, does it begin with a period? if so, it's an internal command
00:00001C70 B03C002E        	  1923:                 cmp.b   #'.',d0
00:00001C74 6650            	  1924:                 bne     runfile
                            	  1925:         ; interpret as a command
00:00001C76 1018            	  1926:                 move.b  (a0)+,d0        ; get command char
                            	  1927:         ; skip whitespace, advance a0 to start of argument
00:00001C78 0C180020        	  1928: .1:             cmp.b   #$20,(a0)+
00:00001C7C 67FA            	  1929:                 beq     .1
00:00001C7E 5348            	  1930:                 subq    #1,a0           ; back up to first char of argument
00:00001C80 43F81D36        	  1931:                 lea.l   commands,a1
                            	  1932:                 ; D
00:00001C84 B019            	  1933:                 cmp.b   (a1)+,d0
00:00001C86 670000A8        	  1934:                 beq     debug
00:00001C8A B019            	  1935:                 cmp.b   (a1)+,d0
00:00001C8C 670000A2        	  1936:                 beq     debug
                            	  1937:                 ; H
00:00001C90 B019            	  1938:                 cmp.b   (a1)+,d0
00:00001C92 67000082        	  1939:                 beq     hexdumpfile
00:00001C96 B019            	  1940:                 cmp.b   (a1)+,d0
00:00001C98 677C            	  1941:                 beq     hexdumpfile
                            	  1942:                 ; I
00:00001C9A B019            	  1943:                 cmp.b   (a1)+,d0
00:00001C9C 670001B6        	  1944:                 beq     cardinfo
00:00001CA0 B019            	  1945:                 cmp.b   (a1)+,d0
00:00001CA2 670001B0        	  1946:                 beq     cardinfo
                            	  1947:                 ; L
00:00001CA6 B019            	  1948:                 cmp.b   (a1)+,d0
00:00001CA8 67000098        	  1949:                 beq     listfiles
00:00001CAC B019            	  1950:                 cmp.b   (a1)+,d0
00:00001CAE 67000092        	  1951:                 beq     listfiles
                            	  1952:                 ; P
00:00001CB2 B019            	  1953:                 cmp.b   (a1)+,d0
00:00001CB4 673C            	  1954:                 beq     printfile
00:00001CB6 B019            	  1955:                 cmp.b   (a1)+,d0
00:00001CB8 6738            	  1956:                 beq     printfile
                            	  1957:                 ; T
00:00001CBA B019            	  1958:                 cmp.b   (a1)+,d0
00:00001CBC 670000F2        	  1959:                 beq     time
00:00001CC0 B019            	  1960:                 cmp.b   (a1)+,d0
00:00001CC2 670000EC        	  1961:                 beq     time
                            	  1962: 
                            	  1963:         ; attempt to load and run named file
00:00001CC6 5348            	  1964: runfile:        subq    #1,a0           ; back up to first character
00:00001CC8 43F900E00100    	  1965:                 lea.l   loadaddr,a1
00:00001CCE 203C000FFE00    	  1966:                 move.l  #loadlen,d0
                            	  1967:                 sys     ReadFile
00:00001CD4 4E4A            	     1M                 trap    #ReadFile
00:00001CD6 4A00            	  1968:                 tst.b   d0
00:00001CD8 6642            	  1969:                 bne     error
                            	  1970:                 litstr  "\nRUNNING.\n"
00:00001CDA 41FA0004        	     1M                 lea.l   (.str_000213,pc),a0
00:00001CDE 600C            	     2M                 bra     .next_000213
                            	     3M .str_000213:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001CE0 0A52554E4E494E47	     1M                 dc.b    "\nRUNNING.\n"
00:00001CE8 2E0A
                            	     2M                 
00:00001CEA 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000213:
                            	  1971:                 sys     OutStr
00:00001CEC 4E43            	     1M                 trap    #OutStr
00:00001CEE 6000F510        	  1972:                 bra     launchapp
                            	  1973: 
00:00001CF2 45F81EF0        	  1974: printfile:      lea.l   fmt_printfile,a2
00:00001CF6 43F900E00100    	  1975: printfile_:     lea.l   loadaddr,a1
00:00001CFC 203C000FFE00    	  1976:                 move.l  #loadlen,d0
                            	  1977:                 sys     ReadFile
00:00001D02 4E4A            	     1M                 trap    #ReadFile
00:00001D04 4A00            	  1978:                 tst.b   d0
00:00001D06 6614            	  1979:                 bne     error
00:00001D08 2F01            	  1980:                 move.l  d1,-(sp)        ; number of bytes read
00:00001D0A 2F08            	  1981:                 move.l  a0,-(sp)        ; start of buffer
00:00001D0C 204A            	  1982:                 move.l  a2,a0
                            	  1983:                 sys     OutFmt
00:00001D0E 4E44            	     1M                 trap    #OutFmt
00:00001D10 508F            	  1984:                 lea.l   8(sp),sp
00:00001D12 6000FF36        	  1985:                 bra     shell
                            	  1986: 
00:00001D16 45F81EEC        	  1987: hexdumpfile:    lea.l   fmt_hexdump,a2
00:00001D1A 60DA            	  1988:                 bra     printfile_
                            	  1989: 
                            	  1990: error:          litstr  "\n",FMT_ERR
00:00001D1C 41FA0004        	     1M                 lea.l   (.str_000218,pc),a0
00:00001D20 6004            	     2M                 bra     .next_000218
                            	     3M .str_000218:
                            	     4M                 rept    2
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001D22 0A              	     1M                 dc.b    "\n"
                            	     2M                 
00:00001D23 F7              	     1M                 dc.b    FMT_ERR
                            	     2M                 
00:00001D24 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000218:
00:00001D26 3F00            	  1991:                 move.w  d0,-(sp)
                            	  1992:                 sys     OutFmt
00:00001D28 4E44            	     1M                 trap    #OutFmt
00:00001D2A 544F            	  1993:                 addq    #2,sp
00:00001D2C 6000FF1C        	  1994:                 bra     shell
                            	  1995: 
                            	  1996: debug:          brk
00:00001D30 4E4F            	     1M                 trap    #15
00:00001D32 6000FF16        	  1997:                 bra     shell
                            	  1998: 
00:00001D36 4464486849694C6C	  1999: commands:       dc.b    "DdHhIiLlPpTt"
00:00001D3E 50705474
                            	  2000: 
                            	  2001: 
00:00001D42 700A            	  2002: listfiles:      moveq   #$0a,d0
                            	  2003:                 sys     OutChar
00:00001D44 4E42            	     1M                 trap    #OutChar
00:00001D46 4E56FDF8        	  2004:                 link    a6,#-DIRBUFSIZE
00:00001D4A 204F            	  2005:                 move.l  sp,a0
00:00001D4C 70FF            	  2006:                 moveq   #-1,d0                  ; indicates this is the first iteration
                            	  2007: .list:          sys     ListDirectory
00:00001D4E 4E48            	     1M                 trap    #ListDirectory
00:00001D50 4A40            	  2008:                 tst.w   d0
00:00001D52 6B50            	  2009:                 bmi     .listdone
00:00001D54 6654            	  2010:                 bne     .listerror
00:00001D56 2448            	  2011:                 move.l  a0,a2
00:00001D58 08290004000B    	  2012:                 btst.b  #4,FATTRS(a1)
00:00001D5E 6622            	  2013:                 bne     .isdir
                            	  2014:                 litstr  FMT_FNAME," - ",FMT_U32," BYTE(S)\n"
00:00001D60 41FA0004        	     1M                 lea.l   (.str_000224,pc),a0
00:00001D64 6010            	     2M                 bra     .next_000224
                            	     3M .str_000224:
                            	     4M                 rept    4
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001D66 F6              	     1M                 dc.b    FMT_FNAME
                            	     2M                 
00:00001D67 202D20          	     1M                 dc.b    " - "
                            	     2M                 
00:00001D6A E9              	     1M                 dc.b    FMT_U32
                            	     2M                 
00:00001D6B 2042595445285329	     1M                 dc.b    " BYTE(S)\n"
00:00001D73 0A
                            	     2M                 
00:00001D74 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000224:
00:00001D76 2F29001C        	  2015:                 move.l  FSIZE(a1),-(sp)         ; size in bytes
00:00001D7A 2F09            	  2016:                 move.l  a1,-(sp)                ; filename
                            	  2017:                 sys     OutFmt
00:00001D7C 4E44            	     1M                 trap    #OutFmt
00:00001D7E 504F            	  2018:                 addq    #8,sp
00:00001D80 601C            	  2019:                 bra     .1
                            	  2020: .isdir:         litstr  FMT_FNAME," - DIRECTORY\n"
00:00001D82 41FA0004        	     1M                 lea.l   (.str_000227,pc),a0
00:00001D86 6010            	     2M                 bra     .next_000227
                            	     3M .str_000227:
                            	     4M                 rept    2
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001D88 F6              	     1M                 dc.b    FMT_FNAME
                            	     2M                 
00:00001D89 202D204449524543	     1M                 dc.b    " - DIRECTORY\n"
00:00001D91 544F52590A
                            	     2M                 
00:00001D96 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000227:
00:00001D98 2F09            	  2021:                 move.l  a1,-(sp)                ; filename
                            	  2022:                 sys     OutFmt
00:00001D9A 4E44            	     1M                 trap    #OutFmt
00:00001D9C 584F            	  2023:                 addq    #4,sp
00:00001D9E 204A            	  2024: .1:             move.l  a2,a0
00:00001DA0 7000            	  2025:                 moveq   #0,d0                   ; indicates subsequent iteration
00:00001DA2 60AA            	  2026:                 bra     .list
00:00001DA4 4E5E            	  2027: .listdone:      unlk    a6
00:00001DA6 6000FEA2        	  2028:                 bra     shell
00:00001DAA 4E5E            	  2029: .listerror:     unlk    a6
00:00001DAC 6000FF6E        	  2030:                 bra     error
                            	  2031: 
00:00001DB0 4A10            	  2032: time:           tst.b   (a0)            ; no argument? just print time
00:00001DB2 6732            	  2033:                 beq     showtime
                            	  2034:         ; assuming input is formatted correctly, pack into D0 and D1
00:00001DB4 01480000        	  2035:                 movep.l 0(a0),d0
00:00001DB8 C0BC0F0F0F0F    	  2036:                 and.l   #$0F0F0F0F,d0
00:00001DBE E988            	  2037:                 lsl.l   #4,d0
00:00001DC0 03480001        	  2038:                 movep.l 1(a0),d1
00:00001DC4 C2BC0F0F0F0F    	  2039:                 and.l   #$0F0F0F0F,d1
00:00001DCA 8081            	  2040:                 or.l    d1,d0
00:00001DCC 03480008        	  2041:                 movep.l 8(a0),d1
00:00001DD0 C2BC0F0F0F0F    	  2042:                 and.l   #$0F0F0F0F,d1
00:00001DD6 E989            	  2043:                 lsl.l   #4,d1
00:00001DD8 05480009        	  2044:                 movep.l 9(a0),d2
00:00001DDC C4BC0F0F0F0F    	  2045:                 and.l   #$0F0F0F0F,d2
00:00001DE2 8282            	  2046:                 or.l    d2,d1
                            	  2047:                 sys     SetDateTime
00:00001DE4 4E4C            	     1M                 trap    #SetDateTime
                            	  2048: 
                            	  2049: showtime:       sys     GetDateTime
00:00001DE6 4E4B            	     1M                 trap    #GetDateTime
00:00001DE8 4A80            	  2050:                 tst.l   d0
00:00001DEA 6B44            	  2051:                 bmi     .timenotset
00:00001DEC 6718            	  2052:                 beq     .no_rtc
                            	  2053:                 litstr  "\n",FMT_DATE," ",FMT_TIME
00:00001DEE 41FA0004        	     1M                 lea.l   (.str_000232,pc),a0
00:00001DF2 6006            	     2M                 bra     .next_000232
                            	     3M .str_000232:
                            	     4M                 rept    4
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001DF4 0A              	     1M                 dc.b    "\n"
                            	     2M                 
00:00001DF5 F2              	     1M                 dc.b    FMT_DATE
                            	     2M                 
00:00001DF6 20              	     1M                 dc.b    " "
                            	     2M                 
00:00001DF7 F3              	     1M                 dc.b    FMT_TIME
                            	     2M                 
00:00001DF8 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000232:
00:00001DFA 48E7C000        	  2054:                 movem.l d0-d1,-(sp)
                            	  2055:                 sys     OutFmt
00:00001DFE 4E44            	     1M                 trap    #OutFmt
00:00001E00 504F            	  2056:                 addq    #8,sp
00:00001E02 6000FE46        	  2057:                 bra     shell
                            	  2058: .no_rtc:        litstr  "\nNO REAL-TIME CLOCK DETECTED"
00:00001E06 41FA0004        	     1M                 lea.l   (.str_000235,pc),a0
00:00001E0A 601E            	     2M                 bra     .next_000235
                            	     3M .str_000235:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001E0C 0A4E4F205245414C	     1M                 dc.b    "\nNO REAL-TIME CLOCK DETECTED"
00:00001E14 2D54494D4520434C
00:00001E1C 4F434B2044455445
00:00001E24 43544544
                            	     2M                 
00:00001E28 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000235:
                            	  2059:                 sys     OutStr
00:00001E2A 4E43            	     1M                 trap    #OutStr
00:00001E2C 6000FE1C        	  2060:                 bra     shell
                            	  2061: .timenotset:    litstr  "\nTIME NOT SET"
00:00001E30 41FA0004        	     1M                 lea.l   (.str_000238,pc),a0
00:00001E34 600E            	     2M                 bra     .next_000238
                            	     3M .str_000238:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001E36 0A54494D45204E4F	     1M                 dc.b    "\nTIME NOT SET"
00:00001E3E 5420534554
                            	     2M                 
00:00001E43 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000238:
                            	  2062:                 sys     OutStr
00:00001E44 4E43            	     1M                 trap    #OutStr
00:00001E46 6000FE02        	  2063:                 bra     shell
                            	  2064: 
00:00001E4A 41F81EF3        	  2065: help:           lea.l   helpstr,a0
                            	  2066:                 sys     OutStr
00:00001E4E 4E43            	     1M                 trap    #OutStr
00:00001E50 6000FDF8        	  2067:                 bra     shell
                            	  2068: 
00:00001E54 4AB900E00010    	  2069: cardinfo:       tst.l   PARTSIZE
00:00001E5A 6752            	  2070:                 beq     .nocard
00:00001E5C 4E560000        	  2071:                 link    a6,#0
00:00001E60 487900E0002E    	  2072:                 pea     VOLNAME
00:00001E66 3F3900E0001A    	  2073:                 move.w  MAXRDIRENTS,-(sp)
00:00001E6C 3F3900E00020    	  2074:                 move.w  CLUSTERSIZE,-(sp)
00:00001E72 3F3900E00018    	  2075:                 move.w  FATSIZE,-(sp)
00:00001E78 3F3900E0001E    	  2076:                 move.w  RSVDSECTORS,-(sp)
00:00001E7E 3F3900E0001C    	  2077:                 move.w  FATCOPIES,-(sp)
00:00001E84 2F3900E0002A    	  2078:                 move.l  DATASTART,-(sp)
00:00001E8A 2F3900E00022    	  2079:                 move.l  RDIRSECTOR,-(sp)
00:00001E90 2F3900E00026    	  2080:                 move.l  FATSECTOR,-(sp)
00:00001E96 2F3900E00014    	  2081:                 move.l  BPBSECTOR,-(sp)
00:00001E9C 2F3900E00010    	  2082:                 move.l  PARTSIZE,-(sp)
00:00001EA2 41F82020        	  2083:                 lea.l   fmt_cardinfo,a0
                            	  2084:                 sys     OutFmt
00:00001EA6 4E44            	     1M                 trap    #OutFmt
00:00001EA8 4E5E            	  2085:                 unlk    a6
00:00001EAA 6000FD9E        	  2086:                 bra     shell
                            	  2087: .nocard:        litstr  "\nNO CARD INSERTED OR NO VALID FILESYSTEM ON CARD"
00:00001EAE 41FA0004        	     1M                 lea.l   (.str_000243,pc),a0
00:00001EB2 6032            	     2M                 bra     .next_000243
                            	     3M .str_000243:
                            	     4M                 rept    1
                            	     5M                 dc.b    \+
                            	     6M                 endr
00:00001EB4 0A4E4F2043415244	     1M                 dc.b    "\nNO CARD INSERTED OR NO VALID FILESYSTEM ON CARD"
00:00001EBC 20494E5345525445
00:00001EC4 44204F52204E4F20
00:00001ECC 56414C4944204649
00:00001ED4 4C4553595354454D
00:00001EDC 204F4E2043415244
                            	     2M                 
00:00001EE4 00              	     7M                 dc.b    0
                            	     8M                 even
                            	     9M .next_000243:
                            	  2088:                 sys     OutStr
00:00001EE6 4E43            	     1M                 trap    #OutStr
00:00001EE8 6000FD60        	  2089:                 bra     shell
                            	  2090: 
00:00001EEC 0A              	  2091: fmt_hexdump:    dc.b    "\n",FMT_HEXDUMP,"\n",0
00:00001EED F4
00:00001EEE 0A
00:00001EEF 00
00:00001EF0 0A              	  2092: fmt_printfile:  dc.b    "\n",FMT_BUF,0
00:00001EF1 F5
00:00001EF2 00
                            	  2093: 
00:00001EF3 0A434F4D4D414E44	  2094: helpstr:        dc.b    "\nCOMMANDS:\n"
00:00001EFB 533A0A
00:00001EFE 3F20202020202020	  2095:                 dc.b    "?          PRINT THIS HELP MESSAGE\n"
00:00001F06 2020205052494E54
00:00001F0E 2054484953204845
00:00001F16 4C50204D45535341
00:00001F1E 47450A
00:00001F21 3C46494C453E2020	  2096:                 dc.b    "<FILE>     RUN <FILE>\n"
00:00001F29 20202052554E203C
00:00001F31 46494C453E0A
00:00001F37 2E4C202020202020	  2097:                 dc.b    ".L         LIST FILES\n"
00:00001F3F 2020204C49535420
00:00001F47 46494C45530A
00:00001F4D 2E49202020202020	  2098:                 dc.b    ".I         PRINT CARD INFO\n"
00:00001F55 2020205052494E54
00:00001F5D 204341524420494E
00:00001F65 464F0A
00:00001F68 2E50203C46494C45	  2099:                 dc.b    ".P <FILE>  PRINT CONTENTS OF <FILE>\n"
00:00001F70 3E20205052494E54
00:00001F78 20434F4E54454E54
00:00001F80 53204F46203C4649
00:00001F88 4C453E0A
00:00001F8C 2E48203C46494C45	  2100:                 dc.b    ".H <FILE>  HEXDUMP CONTENTS OF <FILE>\n"
00:00001F94 3E20204845584455
00:00001F9C 4D5020434F4E5445
00:00001FA4 4E5453204F46203C
00:00001FAC 46494C453E0A
00:00001FB2 2E54202020202020	  2101:                 dc.b    ".T         PRINT DATE AND TIME\n"
00:00001FBA 2020205052494E54
00:00001FC2 204441544520414E
00:00001FCA 442054494D450A
00:00001FD1 2E54203C44415445	  2102:                 dc.b    ".T <DATE>  SET DATE AND TIME\n"
00:00001FD9 3E20205345542044
00:00001FE1 41544520414E4420
00:00001FE9 54494D450A
00:00001FEE 2020202020202020	  2103:                 dc.b    "             (<DATE> FORMAT IS YYYYMMDDWWhhmmss)\n"
00:00001FF6 2020202020283C44
00:00001FFE 4154453E20464F52
00:00002006 4D41542049532059
00:0000200E 5959594D4D444457
00:00002016 5768686D6D737329
00:0000201E 0A
00:0000201F 00              	  2104:                 dc.b    0
                            	  2105: 
                            	  2106: 
00:00002020 0A50415254495449	  2107: fmt_cardinfo:   dc.b    "\nPARTITION SIZE:                 ",FMT_U32," SECTORS\n"
00:00002028 4F4E2053495A453A
00:00002030 2020202020202020
00:00002038 2020202020202020
00:00002040 20
00:00002041 E9
00:00002042 20534543544F5253
00:0000204A 0A
00:0000204B 42494F5320504152	  2108:                 dc.b    "BIOS PARAMETER BLOCK AT SECTOR  ",FMT_U32,"\n"
00:00002053 414D455445522042
00:0000205B 4C4F434B20415420
00:00002063 534543544F522020
00:0000206B E9
00:0000206C 0A
00:0000206D 46494C4520414C4C	  2109:                 dc.b    "FILE ALLOCATION TABLE AT SECTOR ",FMT_U32,"\n"
00:00002075 4F434154494F4E20
00:0000207D 5441424C45204154
00:00002085 20534543544F5220
00:0000208D E9
00:0000208E 0A
00:0000208F 524F4F5420444952	  2110:                 dc.b    "ROOT DIRECTORY AT SECTOR        ",FMT_U32,"\n"
00:00002097 4543544F52592041
00:0000209F 5420534543544F52
00:000020A7 2020202020202020
00:000020AF E9
00:000020B0 0A
00:000020B1 5354415254204F46	  2111:                 dc.b    "START OF DATA REGION AT SECTOR  ",FMT_U32,"\n"
00:000020B9 2044415441205245
00:000020C1 47494F4E20415420
00:000020C9 534543544F522020
00:000020D1 E9
00:000020D2 0A
00:000020D3 434F50494553204F	  2112:                 dc.b    "COPIES OF FAT:                  ",FMT_U16,"\n"
00:000020DB 46204641543A2020
00:000020E3 2020202020202020
00:000020EB 2020202020202020
00:000020F3 E8
00:000020F4 0A
00:000020F5 5245534552564544	  2113:                 dc.b    "RESERVED SECTORS:               ",FMT_U16,"\n"
00:000020FD 20534543544F5253
00:00002105 3A20202020202020
00:0000210D 2020202020202020
00:00002115 E8
00:00002116 0A
00:00002117 46494C4520414C4C	  2114:                 dc.b    "FILE ALLOCATION TABLE SIZE:     ",FMT_U16," SECTORS\n"
00:0000211F 4F434154494F4E20
00:00002127 5441424C45205349
00:0000212F 5A453A2020202020
00:00002137 E8
00:00002138 20534543544F5253
00:00002140 0A
00:00002141 434C555354455220	  2115:                 dc.b    "CLUSTER SIZE:                   ",FMT_U16," SECTORS\n"
00:00002149 53495A453A202020
00:00002151 2020202020202020
00:00002159 2020202020202020
00:00002161 E8
00:00002162 20534543544F5253
00:0000216A 0A
00:0000216B 4D415820524F4F54	  2116:                 dc.b    "MAX ROOT DIRECTORY ENTRIES:     ",FMT_U16,"\n"
00:00002173 204449524543544F
00:0000217B 525920454E545249
00:00002183 45533A2020202020
00:0000218B E8
00:0000218C 0A
00:0000218D 564F4C554D45204E	  2117:                 dc.b    "VOLUME NAME:                    '",FMT_S,"'\n"
00:00002195 414D453A20202020
00:0000219D 2020202020202020
00:000021A5 2020202020202020
00:000021AD 27
00:000021AE E6
00:000021AF 270A
00:000021B1 00              	  2118:                 dc.b    0
                            	  2119:                 even
                            	  2120: 
                            	  2121: 
                            	  2122: ; pad out the ROM image
                            	  2123:         printt  "Total ROM size:"
                            	  2124:         printv  *
00:000021B2 FF              	  2125:                 dcb.b   ROMSIZE-20-*,$FF
00:000021B3 *
                            	  2126: ; ROM image ends with system info and ROM and version number
                            	  2127: sysinfo:
00:0000FFEC 00B71B00        	  2128: clockspeed:     dc.l    F_CPU
00:0000FFF0 00100000        	  2129: ramsize:        dc.l    RAMSIZE
00:0000FFF4 00010000        	  2130: romsize:        dc.l    ROMSIZE
00:0000FFF8 2020            	  2131: rom_date:       dc.w    ROM_DATE_YEAR
00:0000FFFA 07              	  2132:                 dc.b    ROM_DATE_MONTH
00:0000FFFB 11              	  2133:                 dc.b    ROM_DATE_DAY
00:0000FFFC 0000            	  2134: rom_version:    dc.w    ROM_VER_MAJ
00:0000FFFE 9910            	  2135:                 dc.w    ROM_VER_MIN
                            	  2136: 


Symbols by name:
APPMEMSTART                      E:00E00100
BAUD                             E:0000E100
BAUD_DIV                         E:0000000D
BAUD_DIV_L                       E:0000000D
BAUD_DIV_U                       E:00000000
BPBSECTOR                        E:00E00014
CFCARD                           E:00900000
CFCMD_RDSECTOR                   E:00000020
CF_COMMAND                       E:0000000F
CF_COUNT                         E:00000005
CF_CYLH                          E:0000000B
CF_CYLL                          E:00000009
CF_DATA                          E:00000000
CF_DRIVEHEAD                     E:0000000D
CF_ERROR                         E:00000003
CF_FEATURE                       E:00000003
CF_LBA0                          E:00000007
CF_LBA1                          E:00000009
CF_LBA2                          E:0000000B
CF_LBA3                          E:0000000D
CF_SECTOR                        E:00000007
CF_STATUS                        E:0000000F
CLUSTERSIZE                      E:00E00020
DATASTART                        E:00E0002A
DATE_SEP                         E:00E0000C
DIRBUFSIZE                       E:00000208
DIRENTLEN                        E:00000020
DLL                              E:00000000
DLM                              E:00000002
FATCOPIES                        E:00E0001C
FATSECTOR                        E:00E00026
FATSIZE                          E:00E00018
FATTRS                           E:0000000B
FCLUSTER                         E:0000001A
FCR                              E:00000004
FMT_BASE                         E:000000E0
FMT_BUF                          E:000000F5
FMT_DATE                         E:000000F2
FMT_ERR                          E:000000F7
FMT_FAULTFLAGS                   E:000000F1
FMT_FNAME                        E:000000F6
FMT_H16                          E:000000E4
FMT_H32                          E:000000E5
FMT_HEXDUMP                      E:000000F4
FMT_S                            E:000000E6
FMT_SRFLAGS                      E:000000F0
FMT_TIME                         E:000000F3
FMT_U16                          E:000000E8
FMT_U32                          E:000000E9
FNAME                            E:00000000
FNAMELEN                         E:0000000B
FSERR_BADSECTOR                  E:00000026
FSERR_BPS                        E:00000022
FSERR_INVCLSTR                   E:00000025
FSERR_INVNAME                    E:00000027
FSERR_ISDIR                      E:00000028
FSERR_NMOUNTED                   E:00000023
FSERR_NOTFOUND                   E:00000024
FSERR_TIMEOUT                    E:00000020
FSERR_WRONGTYPE                  E:00000021
FSIZE                            E:0000001C
FSVARLEN                         E:0000002A
FSVARSTART                       E:00E00010
F_CPU                            E:00B71B00
GetDateTime                      E:0000000B
GetSysInfo                       E:0000000D
HEXDIGITS                        E:00E00008
IER                              E:00000002
INCH_VEC                         E:00E00004
INITIAL_SP                       E:00F00000
INPUTBUF                         E:00E0003A
INPUTBUFLEN                      E:00000040
ISR                              E:00000004
LCR                              E:00000006
LSR                              E:0000000A
ListDirectory                    E:00000008
MAXRDIRENTS                      E:00E0001A
MCR                              E:00000008
MCR_CLK                          E:00000002
MCR_COPI                         E:00000000
MCR_LED                          E:00000001
MCR_nSS                          E:00000003
MSR                              E:0000000C
MSR_BTN1                         E:00000006
OUTCH_VEC                        E:00E00000
OutChar                          E:00000002
OutFmt                           E:00000004
OutStr                           E:00000003
PARTSIZE                         E:00E00010
PRbNOCTRLCHARS                   E:00000009
PRbNOECHO                        E:00000008
PromptStr                        E:00000006
RAM                              E:00E00000
RAMEND                           E:00F00000
RAMSIZE                          E:00100000
RDIRSECTOR                       E:00E00022
RESET                            A:000000C0
RHR                              E:00000000
ROM                              E:00000000
ROMSIZE                          E:00010000
ROM_DATE_DAY                     E:00000011
ROM_DATE_MONTH                   E:00000007
ROM_DATE_YEAR                    E:00002020
ROM_VER_MAJ                      E:00000000
ROM_VER_MIN                      E:00009910
RSVDSECTORS                      E:00E0001E
ReadFile                         E:0000000A
ReadSector                       E:00000007
SCR                              E:0000000E
SECTORSIZE                       E:00000200
SEPARATORS                       E:00E0000C
SPR                              E:0000000E
SR_C                             E:00000000
SR_N                             E:00000003
SR_V                             E:00000001
SR_X                             E:00000004
SR_Z                             E:00000002
SYSMEMSIZE                       E:00000100
SYSMEMSTART                      E:00E00000
SYS_Exit                         A:00000404
SYS_FindFile                     A:00000AD8
SYS_GetDateTime                  A:00000AE4
SYS_GetSysInfo                   A:00000BD6
SYS_InChar                       A:000009E0
SYS_ListDirectory                A:00000AC8
SYS_OutChar                      A:00000426
SYS_OutFmt                       A:0000044A
SYS_OutStr                       A:00000430
SYS_PromptStr                    A:000009EA
SYS_ReadFile                     A:00000ADE
SYS_ReadSector                   A:00000A68
SYS_SetDateTime                  A:00000B6A
SYS_WaitBtn                      A:00000408
SetDateTime                      E:0000000C
THOUSANDS_SEP                    E:00E0000E
THR                              E:00000000
TIME_SEP                         E:00E0000D
UART                             E:00A00000
VEC_ADRERROR                     A:0000124C
VEC_AUTOVEC1                     A:000011AA
VEC_AUTOVEC2                     A:000013B2
VEC_AUTOVEC3                     A:000013CE
VEC_AUTOVEC4                     A:000013EA
VEC_AUTOVEC5                     A:00001404
VEC_AUTOVEC6                     A:0000141E
VEC_AUTOVEC7                     A:00001438
VEC_BREAKPT                      A:00001452
VEC_BUSFAULT                     A:00001234
VEC_CHK                          A:000012A4
VEC_DIVBY0                       A:0000128A
VEC_ILLINSTR                     A:00001268
VEC_LINE1010                     A:00001300
VEC_LINE1111                     A:00001322
VEC_PRIVVIOL                     A:000012CA
VEC_RESERVED                     A:00001344
VEC_SPURIOUS                     A:00001390
VEC_TRACE                        A:000012EC
VEC_TRAPV                        A:000012B6
VEC_UNINIVEC                     A:00001362
VOLNAME                          E:00E0002E
_cfcard_sendcmd                  A:00000C08
_cfcard_waitfordata              A:00000C50
_lsb                             A:000009B4
_printhexl                       A:0000027E
_printstr                        A:000002AC
cardinfo                         A:00001E54
cfcard_init                      A:00000BDE
cfcard_sendcmd                   A:00000C02
cfcard_waitfordata               A:00000C4A
clockspeed                       A:0000FFEC
commands                         A:00001D36
crash                            A:0000146A
debug                            A:00001D30
debugprompt                      A:0000150E
dumpregs                         A:0000147C
error                            A:00001D1C
fmt_cardinfo                     A:00002020
fmt_date                         A:0000165A
fmt_grp0regs                     A:000015A1
fmt_hexdump                      A:00001EEC
fmt_jumptable                    A:0000046E
fmt_printfile                    A:00001EF0
fmt_regs                         A:0000152B
fmt_sysinfo                      A:00001634
fmt_usp                          A:0000162D
fmtchar                          A:00000460
fname_decode                     A:000010C8
fname_encode                     A:00000F66
fs_dirnext                       A:00000DAC
fs_errorstr                      A:00000D7E
fs_findfile                      A:00000E1E
fs_loadcluster                   A:00000E70
fs_loadfile                      A:00000F16
fs_loadfileat                    A:00000EB8
fs_mount                         A:00000C7E
fs_nextcluster                   A:00000ED8
fs_rdirlist                      A:00000D8E
fserr_abrt                       A:000016C6
fserr_amnf                       A:000016A2
fserr_badsectr                   A:000017E8
fserr_bbk                        A:0000172A
fserr_idnf                       A:000016E2
fserr_invclstr                   A:000017D0
fserr_invname                    A:000017F4
fserr_isdir                      A:00001806
fserr_nmounted                   A:000017AE
fserr_nocard                     A:0000174A
fserr_noerror                    A:00001698
fserr_not512                     A:0000177C
fserr_notfat16                   A:0000175C
fserr_notfound                   A:000017C0
fserr_other                      A:00001816
fserr_unc                        A:00001700
fserrtable                       A:00001828
grp0_crash                       A:00001474
help                             A:00001E4A
helpstr                          A:00001EF3
hexdigits                        A:0000029C
hexdigits_lc                     A:000014FE
hexdigits_uc                     A:000014EE
hexdumpfile                      A:00001D16
idle                             A:00000400
launchapp                        A:00001200
listfiles                        A:00001D42
loadaddr                         E:00E00100
loadlen                          E:000FFE00
lockup                           A:00000204
printfile                        A:00001CF2
printfile_                       A:00001CF6
printflag                        A:000009A0
printhexbyte                     A:000009AC
printhexword                     A:000009C6
printtime                        A:00001160
prompt                           A:0000148A
ramsize                          A:0000FFF0
ready                            A:000002BE
resume                           A:000014E6
resume_traceon                   A:000014DE
rom_date                         A:0000FFF8
rom_version                      A:0000FFFC
romsize                          A:0000FFF4
runfile                          A:00001CC6
shell                            A:00001C4A
showtime                         A:00001DE6
spi_endxfer                      A:00001120
spi_shiftbyte                    A:0000112C
spi_startxfer                    A:00001110
startshell                       A:00001C28
str_credits                      A:00000232
str_noclock                      A:00001667
str_ramtest                      A:0000025A
str_startup                      A:00000218
str_testfail                     A:00000272
str_testpass                     A:0000026A
str_timenotset                   A:00001684
sysinfo                          A:0000FFEC
testfail                         A:000001EC
testpass                         A:000001DC
time                             A:00001DB0
uart_inchar                      A:00001198
uart_outchar                     A:00001186
validchartable                   A:00000FC8

Symbols by value:
00000000 ROM
00000000 RHR
00000000 CF_DATA
00000000 DLL
00000000 BAUD_DIV_U
00000000 MCR_COPI
00000000 THR
00000000 ROM_VER_MAJ
00000000 SR_C
00000000 FNAME
00000001 SR_V
00000001 MCR_LED
00000002 IER
00000002 MCR_CLK
00000002 DLM
00000002 SR_Z
00000002 OutChar
00000003 CF_ERROR
00000003 OutStr
00000003 CF_FEATURE
00000003 SR_N
00000003 MCR_nSS
00000004 ISR
00000004 OutFmt
00000004 SR_X
00000004 FCR
00000005 CF_COUNT
00000006 LCR
00000006 PromptStr
00000006 MSR_BTN1
00000007 CF_SECTOR
00000007 CF_LBA0
00000007 ROM_DATE_MONTH
00000007 ReadSector
00000008 MCR
00000008 PRbNOECHO
00000008 ListDirectory
00000009 CF_CYLL
00000009 CF_LBA1
00000009 PRbNOCTRLCHARS
0000000A ReadFile
0000000A LSR
0000000B GetDateTime
0000000B FNAMELEN
0000000B CF_LBA2
0000000B FATTRS
0000000B CF_CYLH
0000000C SetDateTime
0000000C MSR
0000000D CF_LBA3
0000000D CF_DRIVEHEAD
0000000D GetSysInfo
0000000D BAUD_DIV_L
0000000D BAUD_DIV
0000000E SPR
0000000E SCR
0000000F CF_COMMAND
0000000F CF_STATUS
00000011 ROM_DATE_DAY
0000001A FCLUSTER
0000001C FSIZE
00000020 CFCMD_RDSECTOR
00000020 FSERR_TIMEOUT
00000020 DIRENTLEN
00000021 FSERR_WRONGTYPE
00000022 FSERR_BPS
00000023 FSERR_NMOUNTED
00000024 FSERR_NOTFOUND
00000025 FSERR_INVCLSTR
00000026 FSERR_BADSECTOR
00000027 FSERR_INVNAME
00000028 FSERR_ISDIR
0000002A FSVARLEN
00000040 INPUTBUFLEN
000000C0 RESET
000000E0 FMT_BASE
000000E4 FMT_H16
000000E5 FMT_H32
000000E6 FMT_S
000000E8 FMT_U16
000000E9 FMT_U32
000000F0 FMT_SRFLAGS
000000F1 FMT_FAULTFLAGS
000000F2 FMT_DATE
000000F3 FMT_TIME
000000F4 FMT_HEXDUMP
000000F5 FMT_BUF
000000F6 FMT_FNAME
000000F7 FMT_ERR
00000100 SYSMEMSIZE
000001DC testpass
000001EC testfail
00000200 SECTORSIZE
00000204 lockup
00000208 DIRBUFSIZE
00000218 str_startup
00000232 str_credits
0000025A str_ramtest
0000026A str_testpass
00000272 str_testfail
0000027E _printhexl
0000029C hexdigits
000002AC _printstr
000002BE ready
00000400 idle
00000404 SYS_Exit
00000408 SYS_WaitBtn
00000426 SYS_OutChar
00000430 SYS_OutStr
0000044A SYS_OutFmt
00000460 fmtchar
0000046E fmt_jumptable
000009A0 printflag
000009AC printhexbyte
000009B4 _lsb
000009C6 printhexword
000009E0 SYS_InChar
000009EA SYS_PromptStr
00000A68 SYS_ReadSector
00000AC8 SYS_ListDirectory
00000AD8 SYS_FindFile
00000ADE SYS_ReadFile
00000AE4 SYS_GetDateTime
00000B6A SYS_SetDateTime
00000BD6 SYS_GetSysInfo
00000BDE cfcard_init
00000C02 cfcard_sendcmd
00000C08 _cfcard_sendcmd
00000C4A cfcard_waitfordata
00000C50 _cfcard_waitfordata
00000C7E fs_mount
00000D7E fs_errorstr
00000D8E fs_rdirlist
00000DAC fs_dirnext
00000E1E fs_findfile
00000E70 fs_loadcluster
00000EB8 fs_loadfileat
00000ED8 fs_nextcluster
00000F16 fs_loadfile
00000F66 fname_encode
00000FC8 validchartable
000010C8 fname_decode
00001110 spi_startxfer
00001120 spi_endxfer
0000112C spi_shiftbyte
00001160 printtime
00001186 uart_outchar
00001198 uart_inchar
000011AA VEC_AUTOVEC1
00001200 launchapp
00001234 VEC_BUSFAULT
0000124C VEC_ADRERROR
00001268 VEC_ILLINSTR
0000128A VEC_DIVBY0
000012A4 VEC_CHK
000012B6 VEC_TRAPV
000012CA VEC_PRIVVIOL
000012EC VEC_TRACE
00001300 VEC_LINE1010
00001322 VEC_LINE1111
00001344 VEC_RESERVED
00001362 VEC_UNINIVEC
00001390 VEC_SPURIOUS
000013B2 VEC_AUTOVEC2
000013CE VEC_AUTOVEC3
000013EA VEC_AUTOVEC4
00001404 VEC_AUTOVEC5
0000141E VEC_AUTOVEC6
00001438 VEC_AUTOVEC7
00001452 VEC_BREAKPT
0000146A crash
00001474 grp0_crash
0000147C dumpregs
0000148A prompt
000014DE resume_traceon
000014E6 resume
000014EE hexdigits_uc
000014FE hexdigits_lc
0000150E debugprompt
0000152B fmt_regs
000015A1 fmt_grp0regs
0000162D fmt_usp
00001634 fmt_sysinfo
0000165A fmt_date
00001667 str_noclock
00001684 str_timenotset
00001698 fserr_noerror
000016A2 fserr_amnf
000016C6 fserr_abrt
000016E2 fserr_idnf
00001700 fserr_unc
0000172A fserr_bbk
0000174A fserr_nocard
0000175C fserr_notfat16
0000177C fserr_not512
000017AE fserr_nmounted
000017C0 fserr_notfound
000017D0 fserr_invclstr
000017E8 fserr_badsectr
000017F4 fserr_invname
00001806 fserr_isdir
00001816 fserr_other
00001828 fserrtable
00001C28 startshell
00001C4A shell
00001CC6 runfile
00001CF2 printfile
00001CF6 printfile_
00001D16 hexdumpfile
00001D1C error
00001D30 debug
00001D36 commands
00001D42 listfiles
00001DB0 time
00001DE6 showtime
00001E4A help
00001E54 cardinfo
00001EEC fmt_hexdump
00001EF0 fmt_printfile
00001EF3 helpstr
00002020 ROM_DATE_YEAR
00002020 fmt_cardinfo
00009910 ROM_VER_MIN
0000E100 BAUD
0000FFEC clockspeed
0000FFEC sysinfo
0000FFF0 ramsize
0000FFF4 romsize
0000FFF8 rom_date
0000FFFC rom_version
00010000 ROMSIZE
000FFE00 loadlen
00100000 RAMSIZE
00900000 CFCARD
00A00000 UART
00B71B00 F_CPU
00E00000 RAM
00E00000 SYSMEMSTART
00E00000 OUTCH_VEC
00E00004 INCH_VEC
00E00008 HEXDIGITS
00E0000C SEPARATORS
00E0000C DATE_SEP
00E0000D TIME_SEP
00E0000E THOUSANDS_SEP
00E00010 FSVARSTART
00E00010 PARTSIZE
00E00014 BPBSECTOR
00E00018 FATSIZE
00E0001A MAXRDIRENTS
00E0001C FATCOPIES
00E0001E RSVDSECTORS
00E00020 CLUSTERSIZE
00E00022 RDIRSECTOR
00E00026 FATSECTOR
00E0002A DATASTART
00E0002E VOLNAME
00E0003A INPUTBUF
00E00100 loadaddr
00E00100 APPMEMSTART
00F00000 RAMEND
00F00000 INITIAL_SP
