Sections:
00: "org0001:e00100" (E00100-E00121)


Source: "hello.asm"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2:         include "68000app.inc"

Source: "68000app.inc"
                            	     1:         include "68000sbc.inc"

Source: "68000sbc.inc"
                            	     1:         include "memory.inc"

Source: "memory.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ROMSIZE         equ     $010000 ;64KB
                            	     4: RAMSIZE         equ     $100000 ;1MB
                            	     5: RAMEND          equ     RAM+RAMSIZE
                            	     6: INITIAL_SP      equ     RAMEND
                            	     7: ;-------------------------------------------------------------------------------
                            	     8: ; Base addresses
                            	     9: ROM             equ     $000000
                            	    10: RAM             equ     $E00000
                            	    11: ;-------------------------------------------------------------------------------
                            	    12: ; Memory reserved for the system
                            	    13: SYSMEMSTART     equ     RAM
                            	    14: SYSMEMSIZE      equ     256
                            	    15:                 rsset	SYSMEMSTART
                            	    16: OUTCH_VEC       rs.l    1
                            	    17: INCH_VEC        rs.l    1
                            	    18: HEXDIGITS       rs.l    1
                            	    19: SEPARATORS      rs.l    1
                            	    20: DATE_SEP        equ     SEPARATORS
                            	    21: TIME_SEP        equ     SEPARATORS+1
                            	    22: THOUSANDS_SEP   equ     SEPARATORS+2
                            	    23: 
                            	    24: ; Mounted filesystem parameters
                            	    25: PARTSIZE        rs.l    1               ; size of the partition in sectors, 0 = not mounted (4 bytes)
                            	    26: BPBSECTOR       rs.l    1               ; sector number of the partition's BIOS Parameter Block (4 bytes)
                            	    27: ; These parameters are in reverse order of those in the BPB,
                            	    28: ; because they are little-endian quantities that need to be byte-swapped
                            	    29: FATSIZE         rs.w    1               ; size of a FAT in sectors (2 bytes)
                            	    30: MAXRDIRENTS     rs.w    1               ; maximum number of root directory entries (2 bytes)
                            	    31: FATCOPIES       rs.w    1               ; number of FATs (padded to 2 bytes)
                            	    32: RSVDSECTORS     rs.w    1               ; number of reserved sectors (2 bytes)
                            	    33: CLUSTERSIZE     rs.w    1               ; number of sectors per cluster (2 bytes)
                            	    34: RDIRSECTOR      rs.l    1               ; sector number of root directory table (4 bytes)
                            	    35: FATSECTOR       rs.l    1               ; sector number of FAT #1 (4 bytes)
                            	    36: DATASTART       rs.l    1               ; sector number of data region start (4 bytes)
                            	    37: VOLNAME         rs.b    12              ; volume label (11 bytes, one extra for padding)
                            	    38: FSVARSTART      equ     PARTSIZE
                            	    39: FSVARLEN        equ     VOLNAME-FSVARSTART+12
                            	    40: 
                            	    41: INPUTBUFLEN     equ     64
                            	    42: INPUTBUF        rs.b    INPUTBUFLEN+2   ; command input buffer
                            	    43: 
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: ; Application programs can be loaded here
                            	    46: APPMEMSTART    equ     SYSMEMSTART+SYSMEMSIZE
                            	    47: 
                            	    48: 

Source: "68000sbc.inc"
                            	     2:         include "macros.inc"

Source: "macros.inc"
                            	     1: ; breakpoint (68000 does not have the BKPT instruction)
                            	     2: brk             macro
                            	     3:                 trap    #15
                            	     4:                 endm
                            	     5: 
                            	     6: ; set overflow flag
                            	     7: sev             macro
                            	     8:                 or      #%00000010,ccr
                            	     9:                 endm
                            	    10: 
                            	    11: ; clear overflow flag
                            	    12: clv             macro
                            	    13:                 and     #%11111101,ccr
                            	    14:                 endm
                            	    15: 
                            	    16: ; convenience alias for saving registers on stack
                            	    17: pushm           macro
                            	    18:         if NARG>1
                            	    19:         fail    multiple args passed to pushm--did you use a comma instead of a slash?
                            	    20:         endif
                            	    21:                 movem.l \1,-(sp)
                            	    22:                 endm
                            	    23: push            macro
                            	    24:         if NARG>1
                            	    25:         fail    multiple args passed to push--use pushm if you want to push multiple registers
                            	    26:         endif
                            	    27:                 move.l  \1,-(sp)
                            	    28:                 endm
                            	    29: 
                            	    30: ; convenience alias for restoring registers from stack
                            	    31: popm            macro
                            	    32:         if NARG>1
                            	    33:         fail    multiple args passed to popm--did you use a comma instead of a slash?
                            	    34:         endif
                            	    35:                 movem.l (sp)+,\1
                            	    36:                 endm
                            	    37: pop             macro
                            	    38:         if NARG>1
                            	    39:         fail    multiple args passed to pop--use popm if you want to pop multiple registers
                            	    40:         endif
                            	    41:                 move.l  (sp)+,\1
                            	    42:                 endm
                            	    43: 
                            	    44: ; Branch to subroutine and link, storing return address in A6.
                            	    45: ; (An optimization for calling leaf functions, a la Arm)
                            	    46: bl              macro
                            	    47:                 lea     (.ret\@,pc),a6
                            	    48:                 bra     \1
                            	    49: .ret\@:
                            	    50:                 endm
                            	    51: 
                            	    52: ; Spin for a given number of iterations. (0-65535)
                            	    53: ; (clobbers d0)
                            	    54: spin            macro
                            	    55:                 move.l  #\1,d0
                            	    56: .spin\@:        dbra    d0,.spin\@
                            	    57:                 endm
                            	    58: 
                            	    59: ; Return from subroutine to address in A6.
                            	    60: rl              macro
                            	    61:                 jmp     (a6)
                            	    62:                 endm
                            	    63: 
                            	    64: ; Declare null-terminated string.
                            	    65: asciz           macro
                            	    66:                 rept    \#
                            	    67:                 dc.b    \+
                            	    68:                 endr
                            	    69:                 dc.b    0
                            	    70:                 even
                            	    71:                 endm
                            	    72: 
                            	    73: ; Declare null-terminated string inline, place its address in A0, and jump
                            	    74: ; over it.
                            	    75: litstr          macro
                            	    76:                 lea.l   (.str\@,pc),a0
                            	    77:                 bra     .next\@
                            	    78: .str\@:
                            	    79:                 rept    \#
                            	    80:                 dc.b    \+
                            	    81:                 endr
                            	    82:                 dc.b    0
                            	    83:                 even
                            	    84: .next\@:
                            	    85:                 endm
                            	    86: 
                            	    87: ; Status register bit offsets
                            	    88: SR_C            equ     0       ; carry flag
                            	    89: SR_V            equ     1       ; overflow flag
                            	    90: SR_Z            equ     2       ; zero flag
                            	    91: SR_N            equ     3       ; negative flag
                            	    92: SR_X            equ     4       ; extend flag
                            	    93: SR_I            equ     8       ; interrupt mask
                            	    94: SR_S            equ     13      ; supervisor mode flag
                            	    95: SR_T            equ     15      ; trace flag
                            	    96: ; Condition code register (lower byte of status register) bit offsets
                            	    97: CCR_C           equ     SR_C
                            	    98: CCR_V           equ     SR_V
                            	    99: CCR_Z           equ     SR_Z
                            	   100: CCR_N           equ     SR_N
                            	   101: CCR_X           equ     SR_X
                            	   102: 
                            	   103: LOUD_NOISES     macro
                            	   104:                 move.l  #$d0d0dd00,d0
                            	   105:                 move.l  #$d1d1dd11,d1
                            	   106:                 move.l  #$d2d2dd22,d2
                            	   107:                 move.l  #$d3d3dd33,d3
                            	   108:                 move.l  #$d4d4dd44,d4
                            	   109:                 move.l  #$d5d5dd55,d5
                            	   110:                 move.l  #$d6d6dd66,d6
                            	   111:                 move.l  #$d7d7dd77,d7
                            	   112:                 move.l  #$a0a0aa00,a0
                            	   113:                 move.l  #$a1a1aa11,a1
                            	   114:                 move.l  #$a2a2aa22,a2
                            	   115:                 move.l  #$a3a3aa33,a3
                            	   116:                 move.l  #$a4a4aa44,a4
                            	   117:                 move.l  #$a5a5aa55,a5
                            	   118:                 move.l  #$a6a6aa66,a6
                            	   119:                 endm

Source: "68000sbc.inc"
                            	     3:         include "uart.inc"

Source: "uart.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ; base address
                            	     4: UART            equ $A00000
                            	     5: 
                            	     6: ; register offsets
                            	     7: RHR             equ 0   ; receive holding register (read)
                            	     8: THR             equ 0   ; transmit holding register (write)
                            	     9: IER             equ 2   ; interrupt enable register
                            	    10: ISR             equ 4   ; interrupt status register (read)
                            	    11: FCR             equ 4   ; FIFO control register (write)
                            	    12: LCR             equ 6   ; line control register
                            	    13: MCR             equ 8   ; modem control register
                            	    14: LSR             equ 10  ; line status register
                            	    15: MSR             equ 12  ; modem status register
                            	    16: SPR             equ 14  ; scratchpad register (reserved for system use)
                            	    17: DLL             equ 0   ; divisor latch LSB
                            	    18: DLM             equ 2   ; divisor latch MSB
                            	    19: ; aliases for register names (used by different manufacturers)
                            	    20: RBR             equ RHR ; receive buffer register
                            	    21: IIR             equ ISR ; interrupt identification register
                            	    22: SCR             equ SPR ; scratch register
                            	    23: 
                            	    24: ; MCR register bits (output lines)
                            	    25: ; A bit value of 1 drives the output low
                            	    26: MCR_COPI        equ 0   ; ~DTR -- bit 0 allows for easier shifting
                            	    27: MCR_LED         equ 1   ; ~RTS
                            	    28: MCR_CLK         equ 2   ; ~OUT1
                            	    29: MCR_nSS         equ 3   ; ~OUT2
                            	    30: 
                            	    31: ; MSR register bits (input lines)
                            	    32: MSR_BTN1        equ 6   ; ~RI
                            	    33: MSR_BTN1_PRESS  equ 2   ; TERI
                            	    34: MSR_SQW         equ 5   ; ~DSR
                            	    35: MSR_SQW_CHG     equ 2   ; deltaDSR
                            	    36: MSR_CIPO        equ 7   ; ~DSR -- bit 7 allows for easier shifting
                            	    37: 
                            	    38: ; Wait for the UART to become ready to transmit a character.
                            	    39: ; Macro argument 1: register containing the UART base address
                            	    40: tx_wait         macro
                            	    41: .t\@!:          btst.b  #5,LSR(\1)
                            	    42:                 beq     .t\@@
                            	    43:                 endm
                            	    44: 
                            	    45: ; Transmit a character on the serial port.
                            	    46: ; Macro argument 1: effective address of value to transmit
                            	    47: ; Macro argument 2: register containing the UART base address
                            	    48: tx_char         macro
                            	    49:                 tx_wait \2
                            	    50:                 move.b  \1,THR(\2)
                            	    51:                 endm
                            	    52: 
                            	    53: led_on          macro
                            	    54:                 bset.b  #MCR_LED,UART+MCR
                            	    55:                 endm
                            	    56: 
                            	    57: led_off         macro
                            	    58:                 bclr.b  #MCR_LED,UART+MCR
                            	    59:                 endm
                            	    60: 
                            	    61: led_tgl         macro
                            	    62:                 bchg.b  #MCR_LED,UART+MCR
                            	    63:                 endm

Source: "68000sbc.inc"
                            	     4:         include "cfcard.inc"

Source: "cfcard.inc"
                            	     1: ; vim:noet:sw=8:ts=8:sts=8:ai:syn=asm68k
                            	     2: 
                            	     3: ; base address
                            	     4: CFCARD          equ     $900000
                            	     5: 
                            	     6: ; task file register offsets
                            	     7: CF_DATA         equ     0       ; data register (16-bit read/write)
                            	     8: CF_ERROR        equ     3       ; error register (8-bit read)
                            	     9: CF_FEATURE      equ     3       ; feature register (8-bit write)
                            	    10: CF_COUNT        equ     5       ; sector count register (8-bit read/write)
                            	    11: CF_SECTOR       equ     7       ; sector number register (8-bit read/write)
                            	    12: CF_LBA0         equ     7       ;  also, LBA bits 7-0
                            	    13: CF_CYLL         equ     9       ; cylinder low register (8-bit read/write)
                            	    14: CF_LBA1         equ     9       ;  also, LBA bits 15-8
                            	    15: CF_CYLH         equ     11      ; cylinder high register (8-bit read/write)
                            	    16: CF_LBA2         equ     11      ;  also, LBA bits 23-16
                            	    17: CF_DRIVEHEAD    equ     13      ; drive select/head register (8-bit read/write)
                            	    18: CF_LBA3         equ     13      ;  also, LBA bits 27-24
                            	    19: CF_STATUS       equ     15      ; status register (8-bit read)
                            	    20: CF_COMMAND      equ     15      ; command register (8-bit write)
                            	    21: 
                            	    22: ; task file register offsets for word access
                            	    23: CF_ERROR_W      equ     CF_ERROR-1
                            	    24: CF_FEATURE_W    equ     CF_FEATURE-1
                            	    25: CF_COUNT_W      equ     CF_COUNT-1
                            	    26: CF_SECTOR_W     equ     CF_SECTOR-1
                            	    27: CF_LBA0_W       equ     CF_LBA0-1
                            	    28: CF_CYLL_W       equ     CF_CYLL-1
                            	    29: CF_LBA1_W       equ     CF_LBA1-1
                            	    30: CF_CYLH_W       equ     CF_CYLH-1
                            	    31: CF_LBA2_W       equ     CF_LBA2-1
                            	    32: CF_DRIVEHEAD_W  equ     CF_DRIVEHEAD-1
                            	    33: CF_LBA3_W       equ     CF_LBA3-1
                            	    34: CF_STATUS_W     equ     CF_STATUS-1
                            	    35: CF_COMMAND_W    equ     CF_COMMAND-1
                            	    36: 
                            	    37: ; commands
                            	    38: CFCMD_IDENTIFY  equ     $EC
                            	    39: CFCMD_RDSECTOR  equ     $20
                            	    40: 
                            	    41: ; errors
                            	    42: ; if bit 5 is clear, it's an error reported by the card
                            	    43: ; if bit 5 is set, it's a filesystem error
                            	    44: FSERR_TIMEOUT   equ     32      ; no card detected
                            	    45: FSERR_WRONGTYPE equ     33      ; filesystem is not FAT16
                            	    46: FSERR_BPS       equ     34      ; bytes per sector is not 512
                            	    47: FSERR_NMOUNTED  equ     35      ; filesystem not mounted
                            	    48: FSERR_NOTFOUND  equ     36      ; file not found
                            	    49: FSERR_INVCLSTR  equ     37      ; invalid cluster number
                            	    50: FSERR_BADSECTOR equ     38      ; cluster contains a bad sector
                            	    51: FSERR_INVNAME   equ     39      ; invalid filename
                            	    52: FSERR_ISDIR     equ     40      ; file is a directory
                            	    53: 
                            	    54: ; Size of a sector. Hardcoded.
                            	    55: ; Drives with a different sector size are not supported.
                            	    56: SECTORSIZE      equ     512
                            	    57: ; Size of the buffer required for directory listing
                            	    58: DIRBUFSIZE      equ     SECTORSIZE+8
                            	    59: ; Size of a FAT16 directory entry
                            	    60: DIRENTLEN       equ     32
                            	    61: 
                            	    62: ; FAT16 directory entry field offsets
                            	    63: FNAME           equ     0
                            	    64: FNAMELEN        equ     11
                            	    65: FATTRS          equ     11
                            	    66: FCLUSTER        equ     26
                            	    67: FSIZE           equ     28
                            	    68: 

Source: "68000sbc.inc"
                            	     5:         include "syscalls.inc"

Source: "syscalls.inc"
                            	     1: ; Calling conventions for system routines
                            	     2: ;-------------------------------------------------------------------------------
                            	     3: ; D0-D1 - integer arguments
                            	     4: ; A0-A1 - pointer arguments
                            	     5: ; Additional arguments passed on the stack.
                            	     6: ;
                            	     7: ; D0-D1 - integer return values
                            	     8: ; A0-A1 - pointer return values
                            	     9: ; D2-D7 - preserved
                            	    10: ; A2-A7 - preserved
                            	    11: ; SR    - preserved
                            	    12: ;
                            	    13: ; Registers D0-D1/A0-A1 not used for return values may have undefined contents
                            	    14: ; upon return to the caller. (i.e. the callee may use them as scratch registers)
                            	    15: ;
                            	    16: ; The caller is responsible for removing arguments passed on the stack.
                            	    17: ;
                            	    18: Exit            equ     0
                            	    19: WaitBtn         equ     1
                            	    20: OutChar         equ     2
                            	    21: OutStr          equ     3
                            	    22: OutFmt          equ     4
                            	    23: InChar          equ     5
                            	    24: PromptStr       equ     6
                            	    25: ReadSector      equ     7
                            	    26: ListDirectory   equ     8
                            	    27: FindFile        equ     9
                            	    28: ReadFile        equ     10
                            	    29: GetDateTime     equ     11
                            	    30: SetDateTime     equ     12
                            	    31: GetSysInfo      equ     13
                            	    32: ; 14 - reserved for future use
                            	    33: Breakpoint      equ     15
                            	    34: 
                            	    35: 
                            	    36: ; Syscall macro.
                            	    37: sys             macro
                            	    38:                 trap    #\1
                            	    39:                 endm
                            	    40: 
                            	    41: ; format specifiers for OutFmt
                            	    42: FMT_BASE        equ     $E0
                            	    43: FMT_C           equ     FMT_BASE+0      ;pop word and print lsb as an ASCII character
                            	    44: FMT_C2          equ     FMT_BASE+1      ;pop word and print as two ASCII characters
                            	    45: FMT_C4          equ     FMT_BASE+2      ;pop longword and print as four ASCII characters
                            	    46: FMT_H8          equ     FMT_BASE+3      ;pop word and print lsb as two hex digits
                            	    47: FMT_H16         equ     FMT_BASE+4      ;pop word and print as four hex digits
                            	    48: FMT_H32         equ     FMT_BASE+5      ;pop longword and print as eight hex digits
                            	    49: FMT_S           equ     FMT_BASE+6      ;pop longword and print null-terminated ASCII string at address
                            	    50: FMT_U8          equ     FMT_BASE+7      ;pop word and print lsb as 1-3 decimal digits (unsigned)
                            	    51: FMT_U16         equ     FMT_BASE+8      ;pop word and print as 1-5 decimal digits (unsigned)
                            	    52: FMT_U32         equ     FMT_BASE+9      ;pop longword and print as 1-10 decimal digits (unsigned)
                            	    53: FMT_D8          equ     FMT_BASE+10     ;pop word and print lsb as 1-3 decimal digits (signed)
                            	    54: FMT_D16         equ     FMT_BASE+11     ;pop word and print as 1-5 decimal digits (signed)
                            	    55: FMT_D32         equ     FMT_BASE+12     ;pop longword and print as 1-10 decimal digits (signed)
                            	    56: FMT_Z8          equ     FMT_BASE+13     ;pop word and print lsb as 5 decimal digits with leading zeros (unsigned)
                            	    57: FMT_Z16         equ     FMT_BASE+14     ;pop word and print as 3 decimal digits with leading zeros (unsigned)
                            	    58: FMT_Z32         equ     FMT_BASE+15     ;pop longword and print as 10 decimal digits with leading zeros (unsigned)
                            	    59: FMT_SRFLAGS     equ     FMT_BASE+16     ;pop word and print as status register flags
                            	    60: FMT_FAULTFLAGS  equ     FMT_BASE+17     ;pop word and print as bus/address error fault flags
                            	    61: FMT_DATE        equ     FMT_BASE+18     ;pop longword and print as date (YYYY/MM/DD)
                            	    62: FMT_TIME        equ     FMT_BASE+19     ;pop longword and print as time (HH:MM:SS)
                            	    63: FMT_HEXDUMP     equ     FMT_BASE+20     ;pop longword length and longword address, print as hex dump
                            	    64: FMT_BUF         equ     FMT_BASE+21     ;pop longword length and longword address, print as ASCII
                            	    65: FMT_FNAME       equ     FMT_BASE+22     ;pop longword address and print 11 characters as a decoded filename
                            	    66: FMT_ERR         equ     FMT_BASE+23     ;pop word and print description of the error code in the lsb
                            	    67: 
                            	    68: ; option flags for PromptStr
                            	    69: PRbNOECHO       equ     8
                            	    70: PRbNOCTRLCHARS  equ     9
                            	    71: 
                            	    72: PR_NOECHO       equ     (1<<PRbNOECHO)          ;do not echo characters received to output device
                            	    73: PR_NOCTRLCHARS  equ     (1<<PRbNOCTRLCHARS)     ;do not interpret control characters
                            	    74: 

Source: "68000app.inc"
                            	     2:         org     APPMEMSTART
                            	     3: 

Source: "hello.asm"
                            	     3: start:          sys     WaitBtn
00:00E00100 4E41            	     1M                 trap    #WaitBtn
                            	     4:                 led_tgl
00:00E00102 0879000100A00008	     1M                 bchg.b  #MCR_LED,UART+MCR
00:00E0010A 41FA0006        	     5:                 lea.l   str,a0
                            	     6:                 sys     OutStr
00:00E0010E 4E43            	     1M                 trap    #OutStr
00:00E00110 60EE            	     7:                 bra     start
00:00E00112 68656C6C6F20776F	     8: str:            dc.b    "hello world!!\n",0
00:00E0011A 726C6421210A
00:00E00120 00
                            	     9: 


Symbols by name:
APPMEMSTART                      E:00E00100
CF_COMMAND                       E:0000000F
CF_COUNT                         E:00000005
CF_CYLH                          E:0000000B
CF_CYLL                          E:00000009
CF_DRIVEHEAD                     E:0000000D
CF_ERROR                         E:00000003
CF_FEATURE                       E:00000003
CF_LBA0                          E:00000007
CF_LBA1                          E:00000009
CF_LBA2                          E:0000000B
CF_LBA3                          E:0000000D
CF_SECTOR                        E:00000007
CF_STATUS                        E:0000000F
FMT_BASE                         E:000000E0
FSVARSTART                       E:00E00010
INPUTBUFLEN                      E:00000040
ISR                              E:00000004
MCR                              E:00000008
MCR_LED                          E:00000001
OutStr                           E:00000003
PARTSIZE                         E:00E00010
PRbNOCTRLCHARS                   E:00000009
PRbNOECHO                        E:00000008
RAM                              E:00E00000
RAMEND                           E:00F00000
RAMSIZE                          E:00100000
RHR                              E:00000000
SECTORSIZE                       E:00000200
SEPARATORS                       E:00E0000C
SPR                              E:0000000E
SR_C                             E:00000000
SR_N                             E:00000003
SR_V                             E:00000001
SR_X                             E:00000004
SR_Z                             E:00000002
SYSMEMSIZE                       E:00000100
SYSMEMSTART                      E:00E00000
UART                             E:00A00000
VOLNAME                          E:00E0002E
WaitBtn                          E:00000001
start                            A:00E00100
str                              A:00E00112

Symbols by value:
00000000 SR_C
00000000 RHR
00000001 SR_V
00000001 WaitBtn
00000001 MCR_LED
00000002 SR_Z
00000003 CF_FEATURE
00000003 OutStr
00000003 CF_ERROR
00000003 SR_N
00000004 ISR
00000004 SR_X
00000005 CF_COUNT
00000007 CF_LBA0
00000007 CF_SECTOR
00000008 PRbNOECHO
00000008 MCR
00000009 CF_CYLL
00000009 PRbNOCTRLCHARS
00000009 CF_LBA1
0000000B CF_CYLH
0000000B CF_LBA2
0000000D CF_LBA3
0000000D CF_DRIVEHEAD
0000000E SPR
0000000F CF_COMMAND
0000000F CF_STATUS
00000040 INPUTBUFLEN
000000E0 FMT_BASE
00000100 SYSMEMSIZE
00000200 SECTORSIZE
00100000 RAMSIZE
00A00000 UART
00E00000 RAM
00E00000 SYSMEMSTART
00E0000C SEPARATORS
00E00010 FSVARSTART
00E00010 PARTSIZE
00E0002E VOLNAME
00E00100 start
00E00100 APPMEMSTART
00E00112 str
00F00000 RAMEND
